import{g as ge}from"./PublishEditor-164de56a.js";import"./app-8f633995.js";var xt=function(t){if(t=t||{},this.Promise=t.Promise||Promise,this.queues=Object.create(null),this.domainReentrant=t.domainReentrant||!1,this.domainReentrant){if(typeof process>"u"||typeof process.domain>"u")throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill.");this.domains=Object.create(null)}this.timeout=t.timeout||xt.DEFAULT_TIMEOUT,this.maxOccupationTime=t.maxOccupationTime||xt.DEFAULT_MAX_OCCUPATION_TIME,this.maxExecutionTime=t.maxExecutionTime||xt.DEFAULT_MAX_EXECUTION_TIME,t.maxPending===1/0||Number.isInteger(t.maxPending)&&t.maxPending>=0?this.maxPending=t.maxPending:this.maxPending=xt.DEFAULT_MAX_PENDING};xt.DEFAULT_TIMEOUT=0;xt.DEFAULT_MAX_OCCUPATION_TIME=0;xt.DEFAULT_MAX_EXECUTION_TIME=0;xt.DEFAULT_MAX_PENDING=1e3;xt.prototype.acquire=function(t,e,r,n){if(Array.isArray(t))return this._acquireBatch(t,e,r,n);if(typeof e!="function")throw new Error("You must pass a function to execute");var i=null,a=null,o=null;typeof r!="function"&&(n=r,r=null,o=new this.Promise(function(x,$){i=x,a=$})),n=n||{};var s=!1,h=null,l=null,f=null,d=this,p=function(x,$,A){l&&(clearTimeout(l),l=null),f&&(clearTimeout(f),f=null),x&&(d.queues[t]&&d.queues[t].length===0&&delete d.queues[t],d.domainReentrant&&delete d.domains[t]),s||(o?$?a($):i(A):typeof r=="function"&&r($,A),s=!0),x&&d.queues[t]&&d.queues[t].length>0&&d.queues[t].shift()()},m=function(x){if(s)return p(x);h&&(clearTimeout(h),h=null),d.domainReentrant&&x&&(d.domains[t]=process.domain);var $=n.maxExecutionTime||d.maxExecutionTime;if($&&(f=setTimeout(function(){d.queues[t]&&p(x,new Error("Maximum execution time is exceeded "+t))},$)),e.length===1){var A=!1;try{e(function(B,S){A||(A=!0,p(x,B,S))})}catch(B){A||(A=!0,p(x,B))}}else d._promiseTry(function(){return e()}).then(function(B){p(x,void 0,B)},function(B){p(x,B)})};if(d.domainReentrant&&process.domain&&(m=process.domain.bind(m)),!d.queues[t])d.queues[t]=[],m(!0);else if(d.domainReentrant&&process.domain&&process.domain===d.domains[t])m(!1);else if(d.queues[t].length>=d.maxPending)p(!1,new Error("Too many pending tasks in queue "+t));else{var g=function(){m(!0)};n.skipQueue?d.queues[t].unshift(g):d.queues[t].push(g);var b=n.timeout||d.timeout;b&&(h=setTimeout(function(){h=null,p(!1,new Error("async-lock timed out in queue "+t))},b))}var E=n.maxOccupationTime||d.maxOccupationTime;if(E&&(l=setTimeout(function(){d.queues[t]&&p(!1,new Error("Maximum occupation time is exceeded in queue "+t))},E)),o)return o};xt.prototype._acquireBatch=function(t,e,r,n){typeof r!="function"&&(n=r,r=null);var i=this,a=function(s,h){return function(l){i.acquire(s,h,l,n)}},o=t.reduceRight(function(s,h){return a(h,s)},e);if(typeof r=="function")o(r);else return new this.Promise(function(s,h){o.length===1?o(function(l,f){l?h(l):s(f)}):s(o())})};xt.prototype.isBusy=function(t){return t?!!this.queues[t]:Object.keys(this.queues).length>0};xt.prototype._promiseTry=function(t){try{return this.Promise.resolve(t())}catch(e){return this.Promise.reject(e)}};var Fs=xt,Ns=Fs;const ni=ge(Ns);var ii={exports:{}};typeof Object.create=="function"?ii.exports=function(e,r){r&&(e.super_=r,e.prototype=Object.create(r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:ii.exports=function(e,r){if(r){e.super_=r;var n=function(){};n.prototype=r.prototype,e.prototype=new n,e.prototype.constructor=e}};var Us=ii.exports,ai={exports:{}},to={},gn={};gn.byteLength=zs;gn.toByteArray=js;gn.fromByteArray=Zs;var Lt=[],It=[],Ds=typeof Uint8Array<"u"?Uint8Array:Array,On="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var Ne=0,Ps=On.length;Ne<Ps;++Ne)Lt[Ne]=On[Ne],It[On.charCodeAt(Ne)]=Ne;It["-".charCodeAt(0)]=62;It["_".charCodeAt(0)]=63;function eo(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");r===-1&&(r=e);var n=r===e?0:4-r%4;return[r,n]}function zs(t){var e=eo(t),r=e[0],n=e[1];return(r+n)*3/4-n}function Ms(t,e,r){return(e+r)*3/4-r}function js(t){var e,r=eo(t),n=r[0],i=r[1],a=new Ds(Ms(t,n,i)),o=0,s=i>0?n-4:n,h;for(h=0;h<s;h+=4)e=It[t.charCodeAt(h)]<<18|It[t.charCodeAt(h+1)]<<12|It[t.charCodeAt(h+2)]<<6|It[t.charCodeAt(h+3)],a[o++]=e>>16&255,a[o++]=e>>8&255,a[o++]=e&255;return i===2&&(e=It[t.charCodeAt(h)]<<2|It[t.charCodeAt(h+1)]>>4,a[o++]=e&255),i===1&&(e=It[t.charCodeAt(h)]<<10|It[t.charCodeAt(h+1)]<<4|It[t.charCodeAt(h+2)]>>2,a[o++]=e>>8&255,a[o++]=e&255),a}function Ls(t){return Lt[t>>18&63]+Lt[t>>12&63]+Lt[t>>6&63]+Lt[t&63]}function Hs(t,e,r){for(var n,i=[],a=e;a<r;a+=3)n=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(t[a+2]&255),i.push(Ls(n));return i.join("")}function Zs(t){for(var e,r=t.length,n=r%3,i=[],a=16383,o=0,s=r-n;o<s;o+=a)i.push(Hs(t,o,o+a>s?s:o+a));return n===1?(e=t[r-1],i.push(Lt[e>>2]+Lt[e<<4&63]+"==")):n===2&&(e=(t[r-2]<<8)+t[r-1],i.push(Lt[e>>10]+Lt[e>>4&63]+Lt[e<<2&63]+"=")),i.join("")}var vi={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */vi.read=function(t,e,r,n,i){var a,o,s=i*8-n-1,h=(1<<s)-1,l=h>>1,f=-7,d=r?i-1:0,p=r?-1:1,m=t[e+d];for(d+=p,a=m&(1<<-f)-1,m>>=-f,f+=s;f>0;a=a*256+t[e+d],d+=p,f-=8);for(o=a&(1<<-f)-1,a>>=-f,f+=n;f>0;o=o*256+t[e+d],d+=p,f-=8);if(a===0)a=1-l;else{if(a===h)return o?NaN:(m?-1:1)*(1/0);o=o+Math.pow(2,n),a=a-l}return(m?-1:1)*o*Math.pow(2,a-n)};vi.write=function(t,e,r,n,i,a){var o,s,h,l=a*8-i-1,f=(1<<l)-1,d=f>>1,p=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,m=n?0:a-1,g=n?1:-1,b=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=f):(o=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-o))<1&&(o--,h*=2),o+d>=1?e+=p/h:e+=p*Math.pow(2,1-d),e*h>=2&&(o++,h/=2),o+d>=f?(s=0,o=f):o+d>=1?(s=(e*h-1)*Math.pow(2,i),o=o+d):(s=e*Math.pow(2,d-1)*Math.pow(2,i),o=0));i>=8;t[r+m]=s&255,m+=g,s/=256,i-=8);for(o=o<<i|s,l+=i;l>0;t[r+m]=o&255,m+=g,o/=256,l-=8);t[r+m-g]|=b*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(t){const e=gn,r=vi,n=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=s,t.SlowBuffer=$,t.INSPECT_MAX_BYTES=50;const i=2147483647;t.kMaxLength=i,s.TYPED_ARRAY_SUPPORT=a(),!s.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function a(){try{const w=new Uint8Array(1),c={foo:function(){return 42}};return Object.setPrototypeOf(c,Uint8Array.prototype),Object.setPrototypeOf(w,c),w.foo()===42}catch{return!1}}Object.defineProperty(s.prototype,"parent",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.buffer}}),Object.defineProperty(s.prototype,"offset",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.byteOffset}});function o(w){if(w>i)throw new RangeError('The value "'+w+'" is invalid for option "size"');const c=new Uint8Array(w);return Object.setPrototypeOf(c,s.prototype),c}function s(w,c,u){if(typeof w=="number"){if(typeof c=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return d(w)}return h(w,c,u)}s.poolSize=8192;function h(w,c,u){if(typeof w=="string")return p(w,c);if(ArrayBuffer.isView(w))return g(w);if(w==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof w);if(Dt(w,ArrayBuffer)||w&&Dt(w.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Dt(w,SharedArrayBuffer)||w&&Dt(w.buffer,SharedArrayBuffer)))return b(w,c,u);if(typeof w=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const _=w.valueOf&&w.valueOf();if(_!=null&&_!==w)return s.from(_,c,u);const y=E(w);if(y)return y;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof w[Symbol.toPrimitive]=="function")return s.from(w[Symbol.toPrimitive]("string"),c,u);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof w)}s.from=function(w,c,u){return h(w,c,u)},Object.setPrototypeOf(s.prototype,Uint8Array.prototype),Object.setPrototypeOf(s,Uint8Array);function l(w){if(typeof w!="number")throw new TypeError('"size" argument must be of type number');if(w<0)throw new RangeError('The value "'+w+'" is invalid for option "size"')}function f(w,c,u){return l(w),w<=0?o(w):c!==void 0?typeof u=="string"?o(w).fill(c,u):o(w).fill(c):o(w)}s.alloc=function(w,c,u){return f(w,c,u)};function d(w){return l(w),o(w<0?0:x(w)|0)}s.allocUnsafe=function(w){return d(w)},s.allocUnsafeSlow=function(w){return d(w)};function p(w,c){if((typeof c!="string"||c==="")&&(c="utf8"),!s.isEncoding(c))throw new TypeError("Unknown encoding: "+c);const u=A(w,c)|0;let _=o(u);const y=_.write(w,c);return y!==u&&(_=_.slice(0,y)),_}function m(w){const c=w.length<0?0:x(w.length)|0,u=o(c);for(let _=0;_<c;_+=1)u[_]=w[_]&255;return u}function g(w){if(Dt(w,Uint8Array)){const c=new Uint8Array(w);return b(c.buffer,c.byteOffset,c.byteLength)}return m(w)}function b(w,c,u){if(c<0||w.byteLength<c)throw new RangeError('"offset" is outside of buffer bounds');if(w.byteLength<c+(u||0))throw new RangeError('"length" is outside of buffer bounds');let _;return c===void 0&&u===void 0?_=new Uint8Array(w):u===void 0?_=new Uint8Array(w,c):_=new Uint8Array(w,c,u),Object.setPrototypeOf(_,s.prototype),_}function E(w){if(s.isBuffer(w)){const c=x(w.length)|0,u=o(c);return u.length===0||w.copy(u,0,0,c),u}if(w.length!==void 0)return typeof w.length!="number"||Rn(w.length)?o(0):m(w);if(w.type==="Buffer"&&Array.isArray(w.data))return m(w.data)}function x(w){if(w>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return w|0}function $(w){return+w!=w&&(w=0),s.alloc(+w)}s.isBuffer=function(c){return c!=null&&c._isBuffer===!0&&c!==s.prototype},s.compare=function(c,u){if(Dt(c,Uint8Array)&&(c=s.from(c,c.offset,c.byteLength)),Dt(u,Uint8Array)&&(u=s.from(u,u.offset,u.byteLength)),!s.isBuffer(c)||!s.isBuffer(u))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(c===u)return 0;let _=c.length,y=u.length;for(let I=0,R=Math.min(_,y);I<R;++I)if(c[I]!==u[I]){_=c[I],y=u[I];break}return _<y?-1:y<_?1:0},s.isEncoding=function(c){switch(String(c).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},s.concat=function(c,u){if(!Array.isArray(c))throw new TypeError('"list" argument must be an Array of Buffers');if(c.length===0)return s.alloc(0);let _;if(u===void 0)for(u=0,_=0;_<c.length;++_)u+=c[_].length;const y=s.allocUnsafe(u);let I=0;for(_=0;_<c.length;++_){let R=c[_];if(Dt(R,Uint8Array))I+R.length>y.length?(s.isBuffer(R)||(R=s.from(R)),R.copy(y,I)):Uint8Array.prototype.set.call(y,R,I);else if(s.isBuffer(R))R.copy(y,I);else throw new TypeError('"list" argument must be an Array of Buffers');I+=R.length}return y};function A(w,c){if(s.isBuffer(w))return w.length;if(ArrayBuffer.isView(w)||Dt(w,ArrayBuffer))return w.byteLength;if(typeof w!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof w);const u=w.length,_=arguments.length>2&&arguments[2]===!0;if(!_&&u===0)return 0;let y=!1;for(;;)switch(c){case"ascii":case"latin1":case"binary":return u;case"utf8":case"utf-8":return Xt(w).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return u*2;case"hex":return u>>>1;case"base64":return Pi(w).length;default:if(y)return _?-1:Xt(w).length;c=(""+c).toLowerCase(),y=!0}}s.byteLength=A;function B(w,c,u){let _=!1;if((c===void 0||c<0)&&(c=0),c>this.length||((u===void 0||u>this.length)&&(u=this.length),u<=0)||(u>>>=0,c>>>=0,u<=c))return"";for(w||(w="utf8");;)switch(w){case"hex":return ar(this,c,u);case"utf8":case"utf-8":return G(this,c,u);case"ascii":return wt(this,c,u);case"latin1":case"binary":return Ot(this,c,u);case"base64":return z(this,c,u);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Bt(this,c,u);default:if(_)throw new TypeError("Unknown encoding: "+w);w=(w+"").toLowerCase(),_=!0}}s.prototype._isBuffer=!0;function S(w,c,u){const _=w[c];w[c]=w[u],w[u]=_}s.prototype.swap16=function(){const c=this.length;if(c%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let u=0;u<c;u+=2)S(this,u,u+1);return this},s.prototype.swap32=function(){const c=this.length;if(c%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let u=0;u<c;u+=4)S(this,u,u+3),S(this,u+1,u+2);return this},s.prototype.swap64=function(){const c=this.length;if(c%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let u=0;u<c;u+=8)S(this,u,u+7),S(this,u+1,u+6),S(this,u+2,u+5),S(this,u+3,u+4);return this},s.prototype.toString=function(){const c=this.length;return c===0?"":arguments.length===0?G(this,0,c):B.apply(this,arguments)},s.prototype.toLocaleString=s.prototype.toString,s.prototype.equals=function(c){if(!s.isBuffer(c))throw new TypeError("Argument must be a Buffer");return this===c?!0:s.compare(this,c)===0},s.prototype.inspect=function(){let c="";const u=t.INSPECT_MAX_BYTES;return c=this.toString("hex",0,u).replace(/(.{2})/g,"$1 ").trim(),this.length>u&&(c+=" ... "),"<Buffer "+c+">"},n&&(s.prototype[n]=s.prototype.inspect),s.prototype.compare=function(c,u,_,y,I){if(Dt(c,Uint8Array)&&(c=s.from(c,c.offset,c.byteLength)),!s.isBuffer(c))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof c);if(u===void 0&&(u=0),_===void 0&&(_=c?c.length:0),y===void 0&&(y=0),I===void 0&&(I=this.length),u<0||_>c.length||y<0||I>this.length)throw new RangeError("out of range index");if(y>=I&&u>=_)return 0;if(y>=I)return-1;if(u>=_)return 1;if(u>>>=0,_>>>=0,y>>>=0,I>>>=0,this===c)return 0;let R=I-y,H=_-u;const nt=Math.min(R,H),J=this.slice(y,I),it=c.slice(u,_);for(let K=0;K<nt;++K)if(J[K]!==it[K]){R=J[K],H=it[K];break}return R<H?-1:H<R?1:0};function U(w,c,u,_,y){if(w.length===0)return-1;if(typeof u=="string"?(_=u,u=0):u>2147483647?u=2147483647:u<-2147483648&&(u=-2147483648),u=+u,Rn(u)&&(u=y?0:w.length-1),u<0&&(u=w.length+u),u>=w.length){if(y)return-1;u=w.length-1}else if(u<0)if(y)u=0;else return-1;if(typeof c=="string"&&(c=s.from(c,_)),s.isBuffer(c))return c.length===0?-1:O(w,c,u,_,y);if(typeof c=="number")return c=c&255,typeof Uint8Array.prototype.indexOf=="function"?y?Uint8Array.prototype.indexOf.call(w,c,u):Uint8Array.prototype.lastIndexOf.call(w,c,u):O(w,[c],u,_,y);throw new TypeError("val must be string, number or Buffer")}function O(w,c,u,_,y){let I=1,R=w.length,H=c.length;if(_!==void 0&&(_=String(_).toLowerCase(),_==="ucs2"||_==="ucs-2"||_==="utf16le"||_==="utf-16le")){if(w.length<2||c.length<2)return-1;I=2,R/=2,H/=2,u/=2}function nt(it,K){return I===1?it[K]:it.readUInt16BE(K*I)}let J;if(y){let it=-1;for(J=u;J<R;J++)if(nt(w,J)===nt(c,it===-1?0:J-it)){if(it===-1&&(it=J),J-it+1===H)return it*I}else it!==-1&&(J-=J-it),it=-1}else for(u+H>R&&(u=R-H),J=u;J>=0;J--){let it=!0;for(let K=0;K<H;K++)if(nt(w,J+K)!==nt(c,K)){it=!1;break}if(it)return J}return-1}s.prototype.includes=function(c,u,_){return this.indexOf(c,u,_)!==-1},s.prototype.indexOf=function(c,u,_){return U(this,c,u,_,!0)},s.prototype.lastIndexOf=function(c,u,_){return U(this,c,u,_,!1)};function k(w,c,u,_){u=Number(u)||0;const y=w.length-u;_?(_=Number(_),_>y&&(_=y)):_=y;const I=c.length;_>I/2&&(_=I/2);let R;for(R=0;R<_;++R){const H=parseInt(c.substr(R*2,2),16);if(Rn(H))return R;w[u+R]=H}return R}function N(w,c,u,_){return Wr(Xt(c,w.length-u),w,u,_)}function T(w,c,u,_){return Wr(cr(c),w,u,_)}function C(w,c,u,_){return Wr(Pi(c),w,u,_)}function P(w,c,u,_){return Wr(Rs(c,w.length-u),w,u,_)}s.prototype.write=function(c,u,_,y){if(u===void 0)y="utf8",_=this.length,u=0;else if(_===void 0&&typeof u=="string")y=u,_=this.length,u=0;else if(isFinite(u))u=u>>>0,isFinite(_)?(_=_>>>0,y===void 0&&(y="utf8")):(y=_,_=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const I=this.length-u;if((_===void 0||_>I)&&(_=I),c.length>0&&(_<0||u<0)||u>this.length)throw new RangeError("Attempt to write outside buffer bounds");y||(y="utf8");let R=!1;for(;;)switch(y){case"hex":return k(this,c,u,_);case"utf8":case"utf-8":return N(this,c,u,_);case"ascii":case"latin1":case"binary":return T(this,c,u,_);case"base64":return C(this,c,u,_);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,c,u,_);default:if(R)throw new TypeError("Unknown encoding: "+y);y=(""+y).toLowerCase(),R=!0}},s.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function z(w,c,u){return c===0&&u===w.length?e.fromByteArray(w):e.fromByteArray(w.slice(c,u))}function G(w,c,u){u=Math.min(w.length,u);const _=[];let y=c;for(;y<u;){const I=w[y];let R=null,H=I>239?4:I>223?3:I>191?2:1;if(y+H<=u){let nt,J,it,K;switch(H){case 1:I<128&&(R=I);break;case 2:nt=w[y+1],(nt&192)===128&&(K=(I&31)<<6|nt&63,K>127&&(R=K));break;case 3:nt=w[y+1],J=w[y+2],(nt&192)===128&&(J&192)===128&&(K=(I&15)<<12|(nt&63)<<6|J&63,K>2047&&(K<55296||K>57343)&&(R=K));break;case 4:nt=w[y+1],J=w[y+2],it=w[y+3],(nt&192)===128&&(J&192)===128&&(it&192)===128&&(K=(I&15)<<18|(nt&63)<<12|(J&63)<<6|it&63,K>65535&&K<1114112&&(R=K))}}R===null?(R=65533,H=1):R>65535&&(R-=65536,_.push(R>>>10&1023|55296),R=56320|R&1023),_.push(R),y+=H}return Ut(_)}const ut=4096;function Ut(w){const c=w.length;if(c<=ut)return String.fromCharCode.apply(String,w);let u="",_=0;for(;_<c;)u+=String.fromCharCode.apply(String,w.slice(_,_+=ut));return u}function wt(w,c,u){let _="";u=Math.min(w.length,u);for(let y=c;y<u;++y)_+=String.fromCharCode(w[y]&127);return _}function Ot(w,c,u){let _="";u=Math.min(w.length,u);for(let y=c;y<u;++y)_+=String.fromCharCode(w[y]);return _}function ar(w,c,u){const _=w.length;(!c||c<0)&&(c=0),(!u||u<0||u>_)&&(u=_);let y="";for(let I=c;I<u;++I)y+=Os[w[I]];return y}function Bt(w,c,u){const _=w.slice(c,u);let y="";for(let I=0;I<_.length-1;I+=2)y+=String.fromCharCode(_[I]+_[I+1]*256);return y}s.prototype.slice=function(c,u){const _=this.length;c=~~c,u=u===void 0?_:~~u,c<0?(c+=_,c<0&&(c=0)):c>_&&(c=_),u<0?(u+=_,u<0&&(u=0)):u>_&&(u=_),u<c&&(u=c);const y=this.subarray(c,u);return Object.setPrototypeOf(y,s.prototype),y};function L(w,c,u){if(w%1!==0||w<0)throw new RangeError("offset is not uint");if(w+c>u)throw new RangeError("Trying to access beyond buffer length")}s.prototype.readUintLE=s.prototype.readUIntLE=function(c,u,_){c=c>>>0,u=u>>>0,_||L(c,u,this.length);let y=this[c],I=1,R=0;for(;++R<u&&(I*=256);)y+=this[c+R]*I;return y},s.prototype.readUintBE=s.prototype.readUIntBE=function(c,u,_){c=c>>>0,u=u>>>0,_||L(c,u,this.length);let y=this[c+--u],I=1;for(;u>0&&(I*=256);)y+=this[c+--u]*I;return y},s.prototype.readUint8=s.prototype.readUInt8=function(c,u){return c=c>>>0,u||L(c,1,this.length),this[c]},s.prototype.readUint16LE=s.prototype.readUInt16LE=function(c,u){return c=c>>>0,u||L(c,2,this.length),this[c]|this[c+1]<<8},s.prototype.readUint16BE=s.prototype.readUInt16BE=function(c,u){return c=c>>>0,u||L(c,2,this.length),this[c]<<8|this[c+1]},s.prototype.readUint32LE=s.prototype.readUInt32LE=function(c,u){return c=c>>>0,u||L(c,4,this.length),(this[c]|this[c+1]<<8|this[c+2]<<16)+this[c+3]*16777216},s.prototype.readUint32BE=s.prototype.readUInt32BE=function(c,u){return c=c>>>0,u||L(c,4,this.length),this[c]*16777216+(this[c+1]<<16|this[c+2]<<8|this[c+3])},s.prototype.readBigUInt64LE=oe(function(c){c=c>>>0,Q(c,"offset");const u=this[c],_=this[c+7];(u===void 0||_===void 0)&&lt(c,this.length-8);const y=u+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24,I=this[++c]+this[++c]*2**8+this[++c]*2**16+_*2**24;return BigInt(y)+(BigInt(I)<<BigInt(32))}),s.prototype.readBigUInt64BE=oe(function(c){c=c>>>0,Q(c,"offset");const u=this[c],_=this[c+7];(u===void 0||_===void 0)&&lt(c,this.length-8);const y=u*2**24+this[++c]*2**16+this[++c]*2**8+this[++c],I=this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+_;return(BigInt(y)<<BigInt(32))+BigInt(I)}),s.prototype.readIntLE=function(c,u,_){c=c>>>0,u=u>>>0,_||L(c,u,this.length);let y=this[c],I=1,R=0;for(;++R<u&&(I*=256);)y+=this[c+R]*I;return I*=128,y>=I&&(y-=Math.pow(2,8*u)),y},s.prototype.readIntBE=function(c,u,_){c=c>>>0,u=u>>>0,_||L(c,u,this.length);let y=u,I=1,R=this[c+--y];for(;y>0&&(I*=256);)R+=this[c+--y]*I;return I*=128,R>=I&&(R-=Math.pow(2,8*u)),R},s.prototype.readInt8=function(c,u){return c=c>>>0,u||L(c,1,this.length),this[c]&128?(255-this[c]+1)*-1:this[c]},s.prototype.readInt16LE=function(c,u){c=c>>>0,u||L(c,2,this.length);const _=this[c]|this[c+1]<<8;return _&32768?_|4294901760:_},s.prototype.readInt16BE=function(c,u){c=c>>>0,u||L(c,2,this.length);const _=this[c+1]|this[c]<<8;return _&32768?_|4294901760:_},s.prototype.readInt32LE=function(c,u){return c=c>>>0,u||L(c,4,this.length),this[c]|this[c+1]<<8|this[c+2]<<16|this[c+3]<<24},s.prototype.readInt32BE=function(c,u){return c=c>>>0,u||L(c,4,this.length),this[c]<<24|this[c+1]<<16|this[c+2]<<8|this[c+3]},s.prototype.readBigInt64LE=oe(function(c){c=c>>>0,Q(c,"offset");const u=this[c],_=this[c+7];(u===void 0||_===void 0)&&lt(c,this.length-8);const y=this[c+4]+this[c+5]*2**8+this[c+6]*2**16+(_<<24);return(BigInt(y)<<BigInt(32))+BigInt(u+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24)}),s.prototype.readBigInt64BE=oe(function(c){c=c>>>0,Q(c,"offset");const u=this[c],_=this[c+7];(u===void 0||_===void 0)&&lt(c,this.length-8);const y=(u<<24)+this[++c]*2**16+this[++c]*2**8+this[++c];return(BigInt(y)<<BigInt(32))+BigInt(this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+_)}),s.prototype.readFloatLE=function(c,u){return c=c>>>0,u||L(c,4,this.length),r.read(this,c,!0,23,4)},s.prototype.readFloatBE=function(c,u){return c=c>>>0,u||L(c,4,this.length),r.read(this,c,!1,23,4)},s.prototype.readDoubleLE=function(c,u){return c=c>>>0,u||L(c,8,this.length),r.read(this,c,!0,52,8)},s.prototype.readDoubleBE=function(c,u){return c=c>>>0,u||L(c,8,this.length),r.read(this,c,!1,52,8)};function Y(w,c,u,_,y,I){if(!s.isBuffer(w))throw new TypeError('"buffer" argument must be a Buffer instance');if(c>y||c<I)throw new RangeError('"value" argument is out of bounds');if(u+_>w.length)throw new RangeError("Index out of range")}s.prototype.writeUintLE=s.prototype.writeUIntLE=function(c,u,_,y){if(c=+c,u=u>>>0,_=_>>>0,!y){const H=Math.pow(2,8*_)-1;Y(this,c,u,_,H,0)}let I=1,R=0;for(this[u]=c&255;++R<_&&(I*=256);)this[u+R]=c/I&255;return u+_},s.prototype.writeUintBE=s.prototype.writeUIntBE=function(c,u,_,y){if(c=+c,u=u>>>0,_=_>>>0,!y){const H=Math.pow(2,8*_)-1;Y(this,c,u,_,H,0)}let I=_-1,R=1;for(this[u+I]=c&255;--I>=0&&(R*=256);)this[u+I]=c/R&255;return u+_},s.prototype.writeUint8=s.prototype.writeUInt8=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,1,255,0),this[u]=c&255,u+1},s.prototype.writeUint16LE=s.prototype.writeUInt16LE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,2,65535,0),this[u]=c&255,this[u+1]=c>>>8,u+2},s.prototype.writeUint16BE=s.prototype.writeUInt16BE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,2,65535,0),this[u]=c>>>8,this[u+1]=c&255,u+2},s.prototype.writeUint32LE=s.prototype.writeUInt32LE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,4,4294967295,0),this[u+3]=c>>>24,this[u+2]=c>>>16,this[u+1]=c>>>8,this[u]=c&255,u+4},s.prototype.writeUint32BE=s.prototype.writeUInt32BE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,4,4294967295,0),this[u]=c>>>24,this[u+1]=c>>>16,this[u+2]=c>>>8,this[u+3]=c&255,u+4};function ct(w,c,u,_,y){X(c,_,y,w,u,7);let I=Number(c&BigInt(4294967295));w[u++]=I,I=I>>8,w[u++]=I,I=I>>8,w[u++]=I,I=I>>8,w[u++]=I;let R=Number(c>>BigInt(32)&BigInt(4294967295));return w[u++]=R,R=R>>8,w[u++]=R,R=R>>8,w[u++]=R,R=R>>8,w[u++]=R,u}function re(w,c,u,_,y){X(c,_,y,w,u,7);let I=Number(c&BigInt(4294967295));w[u+7]=I,I=I>>8,w[u+6]=I,I=I>>8,w[u+5]=I,I=I>>8,w[u+4]=I;let R=Number(c>>BigInt(32)&BigInt(4294967295));return w[u+3]=R,R=R>>8,w[u+2]=R,R=R>>8,w[u+1]=R,R=R>>8,w[u]=R,u+8}s.prototype.writeBigUInt64LE=oe(function(c,u=0){return ct(this,c,u,BigInt(0),BigInt("0xffffffffffffffff"))}),s.prototype.writeBigUInt64BE=oe(function(c,u=0){return re(this,c,u,BigInt(0),BigInt("0xffffffffffffffff"))}),s.prototype.writeIntLE=function(c,u,_,y){if(c=+c,u=u>>>0,!y){const nt=Math.pow(2,8*_-1);Y(this,c,u,_,nt-1,-nt)}let I=0,R=1,H=0;for(this[u]=c&255;++I<_&&(R*=256);)c<0&&H===0&&this[u+I-1]!==0&&(H=1),this[u+I]=(c/R>>0)-H&255;return u+_},s.prototype.writeIntBE=function(c,u,_,y){if(c=+c,u=u>>>0,!y){const nt=Math.pow(2,8*_-1);Y(this,c,u,_,nt-1,-nt)}let I=_-1,R=1,H=0;for(this[u+I]=c&255;--I>=0&&(R*=256);)c<0&&H===0&&this[u+I+1]!==0&&(H=1),this[u+I]=(c/R>>0)-H&255;return u+_},s.prototype.writeInt8=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,1,127,-128),c<0&&(c=255+c+1),this[u]=c&255,u+1},s.prototype.writeInt16LE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,2,32767,-32768),this[u]=c&255,this[u+1]=c>>>8,u+2},s.prototype.writeInt16BE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,2,32767,-32768),this[u]=c>>>8,this[u+1]=c&255,u+2},s.prototype.writeInt32LE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,4,2147483647,-2147483648),this[u]=c&255,this[u+1]=c>>>8,this[u+2]=c>>>16,this[u+3]=c>>>24,u+4},s.prototype.writeInt32BE=function(c,u,_){return c=+c,u=u>>>0,_||Y(this,c,u,4,2147483647,-2147483648),c<0&&(c=4294967295+c+1),this[u]=c>>>24,this[u+1]=c>>>16,this[u+2]=c>>>8,this[u+3]=c&255,u+4},s.prototype.writeBigInt64LE=oe(function(c,u=0){return ct(this,c,u,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),s.prototype.writeBigInt64BE=oe(function(c,u=0){return re(this,c,u,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Fe(w,c,u,_,y,I){if(u+_>w.length)throw new RangeError("Index out of range");if(u<0)throw new RangeError("Index out of range")}function ne(w,c,u,_,y){return c=+c,u=u>>>0,y||Fe(w,c,u,4),r.write(w,c,u,_,23,4),u+4}s.prototype.writeFloatLE=function(c,u,_){return ne(this,c,u,!0,_)},s.prototype.writeFloatBE=function(c,u,_){return ne(this,c,u,!1,_)};function st(w,c,u,_,y){return c=+c,u=u>>>0,y||Fe(w,c,u,8),r.write(w,c,u,_,52,8),u+8}s.prototype.writeDoubleLE=function(c,u,_){return st(this,c,u,!0,_)},s.prototype.writeDoubleBE=function(c,u,_){return st(this,c,u,!1,_)},s.prototype.copy=function(c,u,_,y){if(!s.isBuffer(c))throw new TypeError("argument should be a Buffer");if(_||(_=0),!y&&y!==0&&(y=this.length),u>=c.length&&(u=c.length),u||(u=0),y>0&&y<_&&(y=_),y===_||c.length===0||this.length===0)return 0;if(u<0)throw new RangeError("targetStart out of bounds");if(_<0||_>=this.length)throw new RangeError("Index out of range");if(y<0)throw new RangeError("sourceEnd out of bounds");y>this.length&&(y=this.length),c.length-u<y-_&&(y=c.length-u+_);const I=y-_;return this===c&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(u,_,y):Uint8Array.prototype.set.call(c,this.subarray(_,y),u),I},s.prototype.fill=function(c,u,_,y){if(typeof c=="string"){if(typeof u=="string"?(y=u,u=0,_=this.length):typeof _=="string"&&(y=_,_=this.length),y!==void 0&&typeof y!="string")throw new TypeError("encoding must be a string");if(typeof y=="string"&&!s.isEncoding(y))throw new TypeError("Unknown encoding: "+y);if(c.length===1){const R=c.charCodeAt(0);(y==="utf8"&&R<128||y==="latin1")&&(c=R)}}else typeof c=="number"?c=c&255:typeof c=="boolean"&&(c=Number(c));if(u<0||this.length<u||this.length<_)throw new RangeError("Out of range index");if(_<=u)return this;u=u>>>0,_=_===void 0?this.length:_>>>0,c||(c=0);let I;if(typeof c=="number")for(I=u;I<_;++I)this[I]=c;else{const R=s.isBuffer(c)?c:s.from(c,y),H=R.length;if(H===0)throw new TypeError('The value "'+c+'" is invalid for argument "value"');for(I=0;I<_-u;++I)this[I+u]=R[I%H]}return this};const ie={};function ae(w,c,u){ie[w]=class extends u{constructor(){super(),Object.defineProperty(this,"message",{value:c.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${w}]`,this.stack,delete this.name}get code(){return w}set code(y){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:y,writable:!0})}toString(){return`${this.name} [${w}]: ${this.message}`}}}ae("ERR_BUFFER_OUT_OF_BOUNDS",function(w){return w?`${w} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),ae("ERR_INVALID_ARG_TYPE",function(w,c){return`The "${w}" argument must be of type number. Received type ${typeof c}`},TypeError),ae("ERR_OUT_OF_RANGE",function(w,c,u){let _=`The value of "${w}" is out of range.`,y=u;return Number.isInteger(u)&&Math.abs(u)>2**32?y=or(String(u)):typeof u=="bigint"&&(y=String(u),(u>BigInt(2)**BigInt(32)||u<-(BigInt(2)**BigInt(32)))&&(y=or(y)),y+="n"),_+=` It must be ${c}. Received ${y}`,_},RangeError);function or(w){let c="",u=w.length;const _=w[0]==="-"?1:0;for(;u>=_+4;u-=3)c=`_${w.slice(u-3,u)}${c}`;return`${w.slice(0,u)}${c}`}function ye(w,c,u){Q(c,"offset"),(w[c]===void 0||w[c+u]===void 0)&&lt(c,w.length-(u+1))}function X(w,c,u,_,y,I){if(w>u||w<c){const R=typeof c=="bigint"?"n":"";let H;throw I>3?c===0||c===BigInt(0)?H=`>= 0${R} and < 2${R} ** ${(I+1)*8}${R}`:H=`>= -(2${R} ** ${(I+1)*8-1}${R}) and < 2 ** ${(I+1)*8-1}${R}`:H=`>= ${c}${R} and <= ${u}${R}`,new ie.ERR_OUT_OF_RANGE("value",H,w)}ye(_,y,I)}function Q(w,c){if(typeof w!="number")throw new ie.ERR_INVALID_ARG_TYPE(c,"number",w)}function lt(w,c,u){throw Math.floor(w)!==w?(Q(w,u),new ie.ERR_OUT_OF_RANGE(u||"offset","an integer",w)):c<0?new ie.ERR_BUFFER_OUT_OF_BOUNDS:new ie.ERR_OUT_OF_RANGE(u||"offset",`>= ${u?1:0} and <= ${c}`,w)}const $t=/[^+/0-9A-Za-z-_]/g;function sr(w){if(w=w.split("=")[0],w=w.trim().replace($t,""),w.length<2)return"";for(;w.length%4!==0;)w=w+"=";return w}function Xt(w,c){c=c||1/0;let u;const _=w.length;let y=null;const I=[];for(let R=0;R<_;++R){if(u=w.charCodeAt(R),u>55295&&u<57344){if(!y){if(u>56319){(c-=3)>-1&&I.push(239,191,189);continue}else if(R+1===_){(c-=3)>-1&&I.push(239,191,189);continue}y=u;continue}if(u<56320){(c-=3)>-1&&I.push(239,191,189),y=u;continue}u=(y-55296<<10|u-56320)+65536}else y&&(c-=3)>-1&&I.push(239,191,189);if(y=null,u<128){if((c-=1)<0)break;I.push(u)}else if(u<2048){if((c-=2)<0)break;I.push(u>>6|192,u&63|128)}else if(u<65536){if((c-=3)<0)break;I.push(u>>12|224,u>>6&63|128,u&63|128)}else if(u<1114112){if((c-=4)<0)break;I.push(u>>18|240,u>>12&63|128,u>>6&63|128,u&63|128)}else throw new Error("Invalid code point")}return I}function cr(w){const c=[];for(let u=0;u<w.length;++u)c.push(w.charCodeAt(u)&255);return c}function Rs(w,c){let u,_,y;const I=[];for(let R=0;R<w.length&&!((c-=2)<0);++R)u=w.charCodeAt(R),_=u>>8,y=u%256,I.push(y),I.push(_);return I}function Pi(w){return e.toByteArray(sr(w))}function Wr(w,c,u,_){let y;for(y=0;y<_&&!(y+u>=c.length||y>=w.length);++y)c[y+u]=w[y];return y}function Dt(w,c){return w instanceof c||w!=null&&w.constructor!=null&&w.constructor.name!=null&&w.constructor.name===c.name}function Rn(w){return w!==w}const Os=function(){const w="0123456789abcdef",c=new Array(256);for(let u=0;u<16;++u){const _=u*16;for(let y=0;y<16;++y)c[_+y]=w[u]+w[y]}return c}();function oe(w){return typeof BigInt>"u"?Cs:w}function Cs(){throw new Error("BigInt not supported")}})(to);/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */(function(t,e){var r=to,n=r.Buffer;function i(o,s){for(var h in o)s[h]=o[h]}n.from&&n.alloc&&n.allocUnsafe&&n.allocUnsafeSlow?t.exports=r:(i(r,e),e.Buffer=a);function a(o,s,h){return n(o,s,h)}a.prototype=Object.create(n.prototype),i(n,a),a.from=function(o,s,h){if(typeof o=="number")throw new TypeError("Argument must not be a number");return n(o,s,h)},a.alloc=function(o,s,h){if(typeof o!="number")throw new TypeError("Argument must be a number");var l=n(o);return s!==void 0?typeof h=="string"?l.fill(s,h):l.fill(s):l.fill(0),l},a.allocUnsafe=function(o){if(typeof o!="number")throw new TypeError("Argument must be a number");return n(o)},a.allocUnsafeSlow=function(o){if(typeof o!="number")throw new TypeError("Argument must be a number");return r.SlowBuffer(o)}})(ai,ai.exports);var ro=ai.exports,no=ro.Buffer;function yn(t,e){this._block=no.alloc(t),this._finalSize=e,this._blockSize=t,this._len=0}yn.prototype.update=function(t,e){typeof t=="string"&&(e=e||"utf8",t=no.from(t,e));for(var r=this._block,n=this._blockSize,i=t.length,a=this._len,o=0;o<i;){for(var s=a%n,h=Math.min(i-o,n-s),l=0;l<h;l++)r[s+l]=t[o+l];a+=h,o+=h,a%n===0&&this._update(r)}return this._len+=i,this};yn.prototype.digest=function(t){var e=this._len%this._blockSize;this._block[e]=128,this._block.fill(0,e+1),e>=this._finalSize&&(this._update(this._block),this._block.fill(0));var r=this._len*8;if(r<=4294967295)this._block.writeUInt32BE(r,this._blockSize-4);else{var n=(r&4294967295)>>>0,i=(r-n)/4294967296;this._block.writeUInt32BE(i,this._blockSize-8),this._block.writeUInt32BE(n,this._blockSize-4)}this._update(this._block);var a=this._hash();return t?a.toString(t):a};yn.prototype._update=function(){throw new Error("_update must be implemented by subclass")};var Gs=yn,Ws=Us,io=Gs,qs=ro.Buffer,Xs=[1518500249,1859775393,-1894007588,-899497514],Ys=new Array(80);function Er(){this.init(),this._w=Ys,io.call(this,64,56)}Ws(Er,io);Er.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this};function Ks(t){return t<<1|t>>>31}function Vs(t){return t<<5|t>>>27}function Qs(t){return t<<30|t>>>2}function Js(t,e,r,n){return t===0?e&r|~e&n:t===2?e&r|e&n|r&n:e^r^n}Er.prototype._update=function(t){for(var e=this._w,r=this._a|0,n=this._b|0,i=this._c|0,a=this._d|0,o=this._e|0,s=0;s<16;++s)e[s]=t.readInt32BE(s*4);for(;s<80;++s)e[s]=Ks(e[s-3]^e[s-8]^e[s-14]^e[s-16]);for(var h=0;h<80;++h){var l=~~(h/20),f=Vs(r)+Js(l,n,i,a)+o+e[h]+Xs[l]|0;o=a,a=i,i=Qs(n),n=r,r=f}this._a=r+this._a|0,this._b=n+this._b|0,this._c=i+this._c|0,this._d=a+this._d|0,this._e=o+this._e|0};Er.prototype._hash=function(){var t=qs.allocUnsafe(20);return t.writeInt32BE(this._a|0,0),t.writeInt32BE(this._b|0,4),t.writeInt32BE(this._c|0,8),t.writeInt32BE(this._d|0,12),t.writeInt32BE(this._e|0,16),t};var tc=Er;const ao=ge(tc);var oo={};/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */(function(t){(function(e){e(typeof DO_NOT_EXPORT_CRC>"u"?t:{})})(function(e){e.version="1.2.2";function r(){for(var k=0,N=new Array(256),T=0;T!=256;++T)k=T,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,k=k&1?-306674912^k>>>1:k>>>1,N[T]=k;return typeof Int32Array<"u"?new Int32Array(N):N}var n=r();function i(k){var N=0,T=0,C=0,P=typeof Int32Array<"u"?new Int32Array(4096):new Array(4096);for(C=0;C!=256;++C)P[C]=k[C];for(C=0;C!=256;++C)for(T=k[C],N=256+C;N<4096;N+=256)T=P[N]=T>>>8^k[T&255];var z=[];for(C=1;C!=16;++C)z[C-1]=typeof Int32Array<"u"?P.subarray(C*256,C*256+256):P.slice(C*256,C*256+256);return z}var a=i(n),o=a[0],s=a[1],h=a[2],l=a[3],f=a[4],d=a[5],p=a[6],m=a[7],g=a[8],b=a[9],E=a[10],x=a[11],$=a[12],A=a[13],B=a[14];function S(k,N){for(var T=N^-1,C=0,P=k.length;C<P;)T=T>>>8^n[(T^k.charCodeAt(C++))&255];return~T}function U(k,N){for(var T=N^-1,C=k.length-15,P=0;P<C;)T=B[k[P++]^T&255]^A[k[P++]^T>>8&255]^$[k[P++]^T>>16&255]^x[k[P++]^T>>>24]^E[k[P++]]^b[k[P++]]^g[k[P++]]^m[k[P++]]^p[k[P++]]^d[k[P++]]^f[k[P++]]^l[k[P++]]^h[k[P++]]^s[k[P++]]^o[k[P++]]^n[k[P++]];for(C+=15;P<C;)T=T>>>8^n[(T^k[P++])&255];return~T}function O(k,N){for(var T=N^-1,C=0,P=k.length,z=0,G=0;C<P;)z=k.charCodeAt(C++),z<128?T=T>>>8^n[(T^z)&255]:z<2048?(T=T>>>8^n[(T^(192|z>>6&31))&255],T=T>>>8^n[(T^(128|z&63))&255]):z>=55296&&z<57344?(z=(z&1023)+64,G=k.charCodeAt(C++)&1023,T=T>>>8^n[(T^(240|z>>8&7))&255],T=T>>>8^n[(T^(128|z>>2&63))&255],T=T>>>8^n[(T^(128|G>>6&15|(z&3)<<4))&255],T=T>>>8^n[(T^(128|G&63))&255]):(T=T>>>8^n[(T^(224|z>>12&15))&255],T=T>>>8^n[(T^(128|z>>6&63))&255],T=T>>>8^n[(T^(128|z&63))&255]);return~T}e.table=n,e.bstr=S,e.buf=U,e.str=O})})(oo);const ec=ge(oo);var ee={};(function(t){var e=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";function r(a,o){return Object.prototype.hasOwnProperty.call(a,o)}t.assign=function(a){for(var o=Array.prototype.slice.call(arguments,1);o.length;){var s=o.shift();if(s){if(typeof s!="object")throw new TypeError(s+"must be non-object");for(var h in s)r(s,h)&&(a[h]=s[h])}}return a},t.shrinkBuf=function(a,o){return a.length===o?a:a.subarray?a.subarray(0,o):(a.length=o,a)};var n={arraySet:function(a,o,s,h,l){if(o.subarray&&a.subarray){a.set(o.subarray(s,s+h),l);return}for(var f=0;f<h;f++)a[l+f]=o[s+f]},flattenChunks:function(a){var o,s,h,l,f,d;for(h=0,o=0,s=a.length;o<s;o++)h+=a[o].length;for(d=new Uint8Array(h),l=0,o=0,s=a.length;o<s;o++)f=a[o],d.set(f,l),l+=f.length;return d}},i={arraySet:function(a,o,s,h,l){for(var f=0;f<h;f++)a[l+f]=o[s+f]},flattenChunks:function(a){return[].concat.apply([],a)}};t.setTyped=function(a){a?(t.Buf8=Uint8Array,t.Buf16=Uint16Array,t.Buf32=Int32Array,t.assign(t,n)):(t.Buf8=Array,t.Buf16=Array,t.Buf32=Array,t.assign(t,i))},t.setTyped(e)})(ee);var kr={},qt={},Ve={},rc=ee,nc=4,zi=0,Mi=1,ic=2;function Qe(t){for(var e=t.length;--e>=0;)t[e]=0}var ac=0,so=1,oc=2,sc=3,cc=258,xi=29,Sr=256,_r=Sr+1+xi,je=30,Ei=19,co=2*_r+1,xe=15,Cn=16,fc=7,ki=256,fo=16,lo=17,uo=18,oi=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],tn=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],lc=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ho=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],uc=512,Kt=new Array((_r+2)*2);Qe(Kt);var hr=new Array(je*2);Qe(hr);var gr=new Array(uc);Qe(gr);var yr=new Array(cc-sc+1);Qe(yr);var Si=new Array(xi);Qe(Si);var sn=new Array(je);Qe(sn);function Fn(t,e,r,n,i){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=t&&t.length}var wo,po,mo;function Nn(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function _o(t){return t<256?gr[t]:gr[256+(t>>>7)]}function br(t,e){t.pending_buf[t.pending++]=e&255,t.pending_buf[t.pending++]=e>>>8&255}function bt(t,e,r){t.bi_valid>Cn-r?(t.bi_buf|=e<<t.bi_valid&65535,br(t,t.bi_buf),t.bi_buf=e>>Cn-t.bi_valid,t.bi_valid+=r-Cn):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function Ht(t,e,r){bt(t,r[e*2],r[e*2+1])}function go(t,e){var r=0;do r|=t&1,t>>>=1,r<<=1;while(--e>0);return r>>>1}function hc(t){t.bi_valid===16?(br(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=t.bi_buf&255,t.bi_buf>>=8,t.bi_valid-=8)}function dc(t,e){var r=e.dyn_tree,n=e.max_code,i=e.stat_desc.static_tree,a=e.stat_desc.has_stree,o=e.stat_desc.extra_bits,s=e.stat_desc.extra_base,h=e.stat_desc.max_length,l,f,d,p,m,g,b=0;for(p=0;p<=xe;p++)t.bl_count[p]=0;for(r[t.heap[t.heap_max]*2+1]=0,l=t.heap_max+1;l<co;l++)f=t.heap[l],p=r[r[f*2+1]*2+1]+1,p>h&&(p=h,b++),r[f*2+1]=p,!(f>n)&&(t.bl_count[p]++,m=0,f>=s&&(m=o[f-s]),g=r[f*2],t.opt_len+=g*(p+m),a&&(t.static_len+=g*(i[f*2+1]+m)));if(b!==0){do{for(p=h-1;t.bl_count[p]===0;)p--;t.bl_count[p]--,t.bl_count[p+1]+=2,t.bl_count[h]--,b-=2}while(b>0);for(p=h;p!==0;p--)for(f=t.bl_count[p];f!==0;)d=t.heap[--l],!(d>n)&&(r[d*2+1]!==p&&(t.opt_len+=(p-r[d*2+1])*r[d*2],r[d*2+1]=p),f--)}}function yo(t,e,r){var n=new Array(xe+1),i=0,a,o;for(a=1;a<=xe;a++)n[a]=i=i+r[a-1]<<1;for(o=0;o<=e;o++){var s=t[o*2+1];s!==0&&(t[o*2]=go(n[s]++,s))}}function wc(){var t,e,r,n,i,a=new Array(xe+1);for(r=0,n=0;n<xi-1;n++)for(Si[n]=r,t=0;t<1<<oi[n];t++)yr[r++]=n;for(yr[r-1]=n,i=0,n=0;n<16;n++)for(sn[n]=i,t=0;t<1<<tn[n];t++)gr[i++]=n;for(i>>=7;n<je;n++)for(sn[n]=i<<7,t=0;t<1<<tn[n]-7;t++)gr[256+i++]=n;for(e=0;e<=xe;e++)a[e]=0;for(t=0;t<=143;)Kt[t*2+1]=8,t++,a[8]++;for(;t<=255;)Kt[t*2+1]=9,t++,a[9]++;for(;t<=279;)Kt[t*2+1]=7,t++,a[7]++;for(;t<=287;)Kt[t*2+1]=8,t++,a[8]++;for(yo(Kt,_r+1,a),t=0;t<je;t++)hr[t*2+1]=5,hr[t*2]=go(t,5);wo=new Fn(Kt,oi,Sr+1,_r,xe),po=new Fn(hr,tn,0,je,xe),mo=new Fn(new Array(0),lc,0,Ei,fc)}function bo(t){var e;for(e=0;e<_r;e++)t.dyn_ltree[e*2]=0;for(e=0;e<je;e++)t.dyn_dtree[e*2]=0;for(e=0;e<Ei;e++)t.bl_tree[e*2]=0;t.dyn_ltree[ki*2]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function vo(t){t.bi_valid>8?br(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function pc(t,e,r,n){vo(t),n&&(br(t,r),br(t,~r)),rc.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}function ji(t,e,r,n){var i=e*2,a=r*2;return t[i]<t[a]||t[i]===t[a]&&n[e]<=n[r]}function Un(t,e,r){for(var n=t.heap[r],i=r<<1;i<=t.heap_len&&(i<t.heap_len&&ji(e,t.heap[i+1],t.heap[i],t.depth)&&i++,!ji(e,n,t.heap[i],t.depth));)t.heap[r]=t.heap[i],r=i,i<<=1;t.heap[r]=n}function Li(t,e,r){var n,i,a=0,o,s;if(t.last_lit!==0)do n=t.pending_buf[t.d_buf+a*2]<<8|t.pending_buf[t.d_buf+a*2+1],i=t.pending_buf[t.l_buf+a],a++,n===0?Ht(t,i,e):(o=yr[i],Ht(t,o+Sr+1,e),s=oi[o],s!==0&&(i-=Si[o],bt(t,i,s)),n--,o=_o(n),Ht(t,o,r),s=tn[o],s!==0&&(n-=sn[o],bt(t,n,s)));while(a<t.last_lit);Ht(t,ki,e)}function si(t,e){var r=e.dyn_tree,n=e.stat_desc.static_tree,i=e.stat_desc.has_stree,a=e.stat_desc.elems,o,s,h=-1,l;for(t.heap_len=0,t.heap_max=co,o=0;o<a;o++)r[o*2]!==0?(t.heap[++t.heap_len]=h=o,t.depth[o]=0):r[o*2+1]=0;for(;t.heap_len<2;)l=t.heap[++t.heap_len]=h<2?++h:0,r[l*2]=1,t.depth[l]=0,t.opt_len--,i&&(t.static_len-=n[l*2+1]);for(e.max_code=h,o=t.heap_len>>1;o>=1;o--)Un(t,r,o);l=a;do o=t.heap[1],t.heap[1]=t.heap[t.heap_len--],Un(t,r,1),s=t.heap[1],t.heap[--t.heap_max]=o,t.heap[--t.heap_max]=s,r[l*2]=r[o*2]+r[s*2],t.depth[l]=(t.depth[o]>=t.depth[s]?t.depth[o]:t.depth[s])+1,r[o*2+1]=r[s*2+1]=l,t.heap[1]=l++,Un(t,r,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],dc(t,e),yo(r,h,t.bl_count)}function Hi(t,e,r){var n,i=-1,a,o=e[0*2+1],s=0,h=7,l=4;for(o===0&&(h=138,l=3),e[(r+1)*2+1]=65535,n=0;n<=r;n++)a=o,o=e[(n+1)*2+1],!(++s<h&&a===o)&&(s<l?t.bl_tree[a*2]+=s:a!==0?(a!==i&&t.bl_tree[a*2]++,t.bl_tree[fo*2]++):s<=10?t.bl_tree[lo*2]++:t.bl_tree[uo*2]++,s=0,i=a,o===0?(h=138,l=3):a===o?(h=6,l=3):(h=7,l=4))}function Zi(t,e,r){var n,i=-1,a,o=e[0*2+1],s=0,h=7,l=4;for(o===0&&(h=138,l=3),n=0;n<=r;n++)if(a=o,o=e[(n+1)*2+1],!(++s<h&&a===o)){if(s<l)do Ht(t,a,t.bl_tree);while(--s!==0);else a!==0?(a!==i&&(Ht(t,a,t.bl_tree),s--),Ht(t,fo,t.bl_tree),bt(t,s-3,2)):s<=10?(Ht(t,lo,t.bl_tree),bt(t,s-3,3)):(Ht(t,uo,t.bl_tree),bt(t,s-11,7));s=0,i=a,o===0?(h=138,l=3):a===o?(h=6,l=3):(h=7,l=4)}}function mc(t){var e;for(Hi(t,t.dyn_ltree,t.l_desc.max_code),Hi(t,t.dyn_dtree,t.d_desc.max_code),si(t,t.bl_desc),e=Ei-1;e>=3&&t.bl_tree[ho[e]*2+1]===0;e--);return t.opt_len+=3*(e+1)+5+5+4,e}function _c(t,e,r,n){var i;for(bt(t,e-257,5),bt(t,r-1,5),bt(t,n-4,4),i=0;i<n;i++)bt(t,t.bl_tree[ho[i]*2+1],3);Zi(t,t.dyn_ltree,e-1),Zi(t,t.dyn_dtree,r-1)}function gc(t){var e=4093624447,r;for(r=0;r<=31;r++,e>>>=1)if(e&1&&t.dyn_ltree[r*2]!==0)return zi;if(t.dyn_ltree[9*2]!==0||t.dyn_ltree[10*2]!==0||t.dyn_ltree[13*2]!==0)return Mi;for(r=32;r<Sr;r++)if(t.dyn_ltree[r*2]!==0)return Mi;return zi}var Gi=!1;function yc(t){Gi||(wc(),Gi=!0),t.l_desc=new Nn(t.dyn_ltree,wo),t.d_desc=new Nn(t.dyn_dtree,po),t.bl_desc=new Nn(t.bl_tree,mo),t.bi_buf=0,t.bi_valid=0,bo(t)}function xo(t,e,r,n){bt(t,(ac<<1)+(n?1:0),3),pc(t,e,r,!0)}function bc(t){bt(t,so<<1,3),Ht(t,ki,Kt),hc(t)}function vc(t,e,r,n){var i,a,o=0;t.level>0?(t.strm.data_type===ic&&(t.strm.data_type=gc(t)),si(t,t.l_desc),si(t,t.d_desc),o=mc(t),i=t.opt_len+3+7>>>3,a=t.static_len+3+7>>>3,a<=i&&(i=a)):i=a=r+5,r+4<=i&&e!==-1?xo(t,e,r,n):t.strategy===nc||a===i?(bt(t,(so<<1)+(n?1:0),3),Li(t,Kt,hr)):(bt(t,(oc<<1)+(n?1:0),3),_c(t,t.l_desc.max_code+1,t.d_desc.max_code+1,o+1),Li(t,t.dyn_ltree,t.dyn_dtree)),bo(t),n&&vo(t)}function xc(t,e,r){return t.pending_buf[t.d_buf+t.last_lit*2]=e>>>8&255,t.pending_buf[t.d_buf+t.last_lit*2+1]=e&255,t.pending_buf[t.l_buf+t.last_lit]=r&255,t.last_lit++,e===0?t.dyn_ltree[r*2]++:(t.matches++,e--,t.dyn_ltree[(yr[r]+Sr+1)*2]++,t.dyn_dtree[_o(e)*2]++),t.last_lit===t.lit_bufsize-1}Ve._tr_init=yc;Ve._tr_stored_block=xo;Ve._tr_flush_block=vc;Ve._tr_tally=xc;Ve._tr_align=bc;function Ec(t,e,r,n){for(var i=t&65535|0,a=t>>>16&65535|0,o=0;r!==0;){o=r>2e3?2e3:r,r-=o;do i=i+e[n++]|0,a=a+i|0;while(--o);i%=65521,a%=65521}return i|a<<16|0}var Eo=Ec;function kc(){for(var t,e=[],r=0;r<256;r++){t=r;for(var n=0;n<8;n++)t=t&1?3988292384^t>>>1:t>>>1;e[r]=t}return e}var Sc=kc();function Bc(t,e,r,n){var i=Sc,a=n+r;t^=-1;for(var o=n;o<a;o++)t=t>>>8^i[(t^e[o])&255];return t^-1}var ko=Bc,Bi={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},mt=ee,At=Ve,So=Eo,ce=ko,$c=Bi,Ae=0,Ic=1,Ac=3,pe=4,Wi=5,Zt=0,qi=1,Tt=-2,Tc=-3,Dn=-5,Rc=-1,Oc=1,qr=2,Cc=3,Fc=4,Nc=0,Uc=2,bn=8,Dc=9,Pc=15,zc=8,Mc=29,jc=256,ci=jc+1+Mc,Lc=30,Hc=19,Zc=2*ci+1,Gc=15,Z=3,ue=258,Ct=ue+Z+1,Wc=32,vn=42,fi=69,en=73,rn=91,nn=103,Ee=113,ur=666,ft=1,Br=2,ke=3,Je=4,qc=3;function he(t,e){return t.msg=$c[e],e}function Xi(t){return(t<<1)-(t>4?9:0)}function le(t){for(var e=t.length;--e>=0;)t[e]=0}function fe(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),r!==0&&(mt.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,e.pending===0&&(e.pending_out=0))}function ht(t,e){At._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,fe(t.strm)}function q(t,e){t.pending_buf[t.pending++]=e}function fr(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=e&255}function Xc(t,e,r,n){var i=t.avail_in;return i>n&&(i=n),i===0?0:(t.avail_in-=i,mt.arraySet(e,t.input,t.next_in,i,r),t.state.wrap===1?t.adler=So(t.adler,e,i,r):t.state.wrap===2&&(t.adler=ce(t.adler,e,i,r)),t.next_in+=i,t.total_in+=i,i)}function Bo(t,e){var r=t.max_chain_length,n=t.strstart,i,a,o=t.prev_length,s=t.nice_match,h=t.strstart>t.w_size-Ct?t.strstart-(t.w_size-Ct):0,l=t.window,f=t.w_mask,d=t.prev,p=t.strstart+ue,m=l[n+o-1],g=l[n+o];t.prev_length>=t.good_match&&(r>>=2),s>t.lookahead&&(s=t.lookahead);do if(i=e,!(l[i+o]!==g||l[i+o-1]!==m||l[i]!==l[n]||l[++i]!==l[n+1])){n+=2,i++;do;while(l[++n]===l[++i]&&l[++n]===l[++i]&&l[++n]===l[++i]&&l[++n]===l[++i]&&l[++n]===l[++i]&&l[++n]===l[++i]&&l[++n]===l[++i]&&l[++n]===l[++i]&&n<p);if(a=ue-(p-n),n=p-ue,a>o){if(t.match_start=e,o=a,a>=s)break;m=l[n+o-1],g=l[n+o]}}while((e=d[e&f])>h&&--r!==0);return o<=t.lookahead?o:t.lookahead}function Se(t){var e=t.w_size,r,n,i,a,o;do{if(a=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-Ct)){mt.arraySet(t.window,t.window,e,e,0),t.match_start-=e,t.strstart-=e,t.block_start-=e,n=t.hash_size,r=n;do i=t.head[--r],t.head[r]=i>=e?i-e:0;while(--n);n=e,r=n;do i=t.prev[--r],t.prev[r]=i>=e?i-e:0;while(--n);a+=e}if(t.strm.avail_in===0)break;if(n=Xc(t.strm,t.window,t.strstart+t.lookahead,a),t.lookahead+=n,t.lookahead+t.insert>=Z)for(o=t.strstart-t.insert,t.ins_h=t.window[o],t.ins_h=(t.ins_h<<t.hash_shift^t.window[o+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[o+Z-1])&t.hash_mask,t.prev[o&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=o,o++,t.insert--,!(t.lookahead+t.insert<Z)););}while(t.lookahead<Ct&&t.strm.avail_in!==0)}function Yc(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(Se(t),t.lookahead===0&&e===Ae)return ft;if(t.lookahead===0)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+r;if((t.strstart===0||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,ht(t,!1),t.strm.avail_out===0)||t.strstart-t.block_start>=t.w_size-Ct&&(ht(t,!1),t.strm.avail_out===0))return ft}return t.insert=0,e===pe?(ht(t,!0),t.strm.avail_out===0?ke:Je):(t.strstart>t.block_start&&(ht(t,!1),t.strm.avail_out===0),ft)}function Pn(t,e){for(var r,n;;){if(t.lookahead<Ct){if(Se(t),t.lookahead<Ct&&e===Ae)return ft;if(t.lookahead===0)break}if(r=0,t.lookahead>=Z&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+Z-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),r!==0&&t.strstart-r<=t.w_size-Ct&&(t.match_length=Bo(t,r)),t.match_length>=Z)if(n=At._tr_tally(t,t.strstart-t.match_start,t.match_length-Z),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=Z){t.match_length--;do t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+Z-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;while(--t.match_length!==0);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else n=At._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(ht(t,!1),t.strm.avail_out===0))return ft}return t.insert=t.strstart<Z-1?t.strstart:Z-1,e===pe?(ht(t,!0),t.strm.avail_out===0?ke:Je):t.last_lit&&(ht(t,!1),t.strm.avail_out===0)?ft:Br}function Ue(t,e){for(var r,n,i;;){if(t.lookahead<Ct){if(Se(t),t.lookahead<Ct&&e===Ae)return ft;if(t.lookahead===0)break}if(r=0,t.lookahead>=Z&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+Z-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=Z-1,r!==0&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-Ct&&(t.match_length=Bo(t,r),t.match_length<=5&&(t.strategy===Oc||t.match_length===Z&&t.strstart-t.match_start>4096)&&(t.match_length=Z-1)),t.prev_length>=Z&&t.match_length<=t.prev_length){i=t.strstart+t.lookahead-Z,n=At._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-Z),t.lookahead-=t.prev_length-1,t.prev_length-=2;do++t.strstart<=i&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+Z-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);while(--t.prev_length!==0);if(t.match_available=0,t.match_length=Z-1,t.strstart++,n&&(ht(t,!1),t.strm.avail_out===0))return ft}else if(t.match_available){if(n=At._tr_tally(t,0,t.window[t.strstart-1]),n&&ht(t,!1),t.strstart++,t.lookahead--,t.strm.avail_out===0)return ft}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=At._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<Z-1?t.strstart:Z-1,e===pe?(ht(t,!0),t.strm.avail_out===0?ke:Je):t.last_lit&&(ht(t,!1),t.strm.avail_out===0)?ft:Br}function Kc(t,e){for(var r,n,i,a,o=t.window;;){if(t.lookahead<=ue){if(Se(t),t.lookahead<=ue&&e===Ae)return ft;if(t.lookahead===0)break}if(t.match_length=0,t.lookahead>=Z&&t.strstart>0&&(i=t.strstart-1,n=o[i],n===o[++i]&&n===o[++i]&&n===o[++i])){a=t.strstart+ue;do;while(n===o[++i]&&n===o[++i]&&n===o[++i]&&n===o[++i]&&n===o[++i]&&n===o[++i]&&n===o[++i]&&n===o[++i]&&i<a);t.match_length=ue-(a-i),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=Z?(r=At._tr_tally(t,1,t.match_length-Z),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=At._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(ht(t,!1),t.strm.avail_out===0))return ft}return t.insert=0,e===pe?(ht(t,!0),t.strm.avail_out===0?ke:Je):t.last_lit&&(ht(t,!1),t.strm.avail_out===0)?ft:Br}function Vc(t,e){for(var r;;){if(t.lookahead===0&&(Se(t),t.lookahead===0)){if(e===Ae)return ft;break}if(t.match_length=0,r=At._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(ht(t,!1),t.strm.avail_out===0))return ft}return t.insert=0,e===pe?(ht(t,!0),t.strm.avail_out===0?ke:Je):t.last_lit&&(ht(t,!1),t.strm.avail_out===0)?ft:Br}function Pt(t,e,r,n,i){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=n,this.func=i}var ze;ze=[new Pt(0,0,0,0,Yc),new Pt(4,4,8,4,Pn),new Pt(4,5,16,8,Pn),new Pt(4,6,32,32,Pn),new Pt(4,4,16,16,Ue),new Pt(8,16,32,32,Ue),new Pt(8,16,128,128,Ue),new Pt(8,32,128,256,Ue),new Pt(32,128,258,1024,Ue),new Pt(32,258,258,4096,Ue)];function Qc(t){t.window_size=2*t.w_size,le(t.head),t.max_lazy_match=ze[t.level].max_lazy,t.good_match=ze[t.level].good_length,t.nice_match=ze[t.level].nice_length,t.max_chain_length=ze[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=Z-1,t.match_available=0,t.ins_h=0}function Jc(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=bn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new mt.Buf16(Zc*2),this.dyn_dtree=new mt.Buf16((2*Lc+1)*2),this.bl_tree=new mt.Buf16((2*Hc+1)*2),le(this.dyn_ltree),le(this.dyn_dtree),le(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new mt.Buf16(Gc+1),this.heap=new mt.Buf16(2*ci+1),le(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new mt.Buf16(2*ci+1),le(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function $o(t){var e;return!t||!t.state?he(t,Tt):(t.total_in=t.total_out=0,t.data_type=Uc,e=t.state,e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?vn:Ee,t.adler=e.wrap===2?0:1,e.last_flush=Ae,At._tr_init(e),Zt)}function Io(t){var e=$o(t);return e===Zt&&Qc(t.state),e}function tf(t,e){return!t||!t.state||t.state.wrap!==2?Tt:(t.state.gzhead=e,Zt)}function Ao(t,e,r,n,i,a){if(!t)return Tt;var o=1;if(e===Rc&&(e=6),n<0?(o=0,n=-n):n>15&&(o=2,n-=16),i<1||i>Dc||r!==bn||n<8||n>15||e<0||e>9||a<0||a>Fc)return he(t,Tt);n===8&&(n=9);var s=new Jc;return t.state=s,s.strm=t,s.wrap=o,s.gzhead=null,s.w_bits=n,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=i+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+Z-1)/Z),s.window=new mt.Buf8(s.w_size*2),s.head=new mt.Buf16(s.hash_size),s.prev=new mt.Buf16(s.w_size),s.lit_bufsize=1<<i+6,s.pending_buf_size=s.lit_bufsize*4,s.pending_buf=new mt.Buf8(s.pending_buf_size),s.d_buf=1*s.lit_bufsize,s.l_buf=(1+2)*s.lit_bufsize,s.level=e,s.strategy=a,s.method=r,Io(t)}function ef(t,e){return Ao(t,e,bn,Pc,zc,Nc)}function rf(t,e){var r,n,i,a;if(!t||!t.state||e>Wi||e<0)return t?he(t,Tt):Tt;if(n=t.state,!t.output||!t.input&&t.avail_in!==0||n.status===ur&&e!==pe)return he(t,t.avail_out===0?Dn:Tt);if(n.strm=t,r=n.last_flush,n.last_flush=e,n.status===vn)if(n.wrap===2)t.adler=0,q(n,31),q(n,139),q(n,8),n.gzhead?(q(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),q(n,n.gzhead.time&255),q(n,n.gzhead.time>>8&255),q(n,n.gzhead.time>>16&255),q(n,n.gzhead.time>>24&255),q(n,n.level===9?2:n.strategy>=qr||n.level<2?4:0),q(n,n.gzhead.os&255),n.gzhead.extra&&n.gzhead.extra.length&&(q(n,n.gzhead.extra.length&255),q(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(t.adler=ce(t.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=fi):(q(n,0),q(n,0),q(n,0),q(n,0),q(n,0),q(n,n.level===9?2:n.strategy>=qr||n.level<2?4:0),q(n,qc),n.status=Ee);else{var o=bn+(n.w_bits-8<<4)<<8,s=-1;n.strategy>=qr||n.level<2?s=0:n.level<6?s=1:n.level===6?s=2:s=3,o|=s<<6,n.strstart!==0&&(o|=Wc),o+=31-o%31,n.status=Ee,fr(n,o),n.strstart!==0&&(fr(n,t.adler>>>16),fr(n,t.adler&65535)),t.adler=1}if(n.status===fi)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(n.gzhead.extra.length&65535)&&!(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(t.adler=ce(t.adler,n.pending_buf,n.pending-i,i)),fe(t),i=n.pending,n.pending===n.pending_buf_size));)q(n,n.gzhead.extra[n.gzindex]&255),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(t.adler=ce(t.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=en)}else n.status=en;if(n.status===en)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(t.adler=ce(t.adler,n.pending_buf,n.pending-i,i)),fe(t),i=n.pending,n.pending===n.pending_buf_size)){a=1;break}n.gzindex<n.gzhead.name.length?a=n.gzhead.name.charCodeAt(n.gzindex++)&255:a=0,q(n,a)}while(a!==0);n.gzhead.hcrc&&n.pending>i&&(t.adler=ce(t.adler,n.pending_buf,n.pending-i,i)),a===0&&(n.gzindex=0,n.status=rn)}else n.status=rn;if(n.status===rn)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(t.adler=ce(t.adler,n.pending_buf,n.pending-i,i)),fe(t),i=n.pending,n.pending===n.pending_buf_size)){a=1;break}n.gzindex<n.gzhead.comment.length?a=n.gzhead.comment.charCodeAt(n.gzindex++)&255:a=0,q(n,a)}while(a!==0);n.gzhead.hcrc&&n.pending>i&&(t.adler=ce(t.adler,n.pending_buf,n.pending-i,i)),a===0&&(n.status=nn)}else n.status=nn;if(n.status===nn&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&fe(t),n.pending+2<=n.pending_buf_size&&(q(n,t.adler&255),q(n,t.adler>>8&255),t.adler=0,n.status=Ee)):n.status=Ee),n.pending!==0){if(fe(t),t.avail_out===0)return n.last_flush=-1,Zt}else if(t.avail_in===0&&Xi(e)<=Xi(r)&&e!==pe)return he(t,Dn);if(n.status===ur&&t.avail_in!==0)return he(t,Dn);if(t.avail_in!==0||n.lookahead!==0||e!==Ae&&n.status!==ur){var h=n.strategy===qr?Vc(n,e):n.strategy===Cc?Kc(n,e):ze[n.level].func(n,e);if((h===ke||h===Je)&&(n.status=ur),h===ft||h===ke)return t.avail_out===0&&(n.last_flush=-1),Zt;if(h===Br&&(e===Ic?At._tr_align(n):e!==Wi&&(At._tr_stored_block(n,0,0,!1),e===Ac&&(le(n.head),n.lookahead===0&&(n.strstart=0,n.block_start=0,n.insert=0))),fe(t),t.avail_out===0))return n.last_flush=-1,Zt}return e!==pe?Zt:n.wrap<=0?qi:(n.wrap===2?(q(n,t.adler&255),q(n,t.adler>>8&255),q(n,t.adler>>16&255),q(n,t.adler>>24&255),q(n,t.total_in&255),q(n,t.total_in>>8&255),q(n,t.total_in>>16&255),q(n,t.total_in>>24&255)):(fr(n,t.adler>>>16),fr(n,t.adler&65535)),fe(t),n.wrap>0&&(n.wrap=-n.wrap),n.pending!==0?Zt:qi)}function nf(t){var e;return!t||!t.state?Tt:(e=t.state.status,e!==vn&&e!==fi&&e!==en&&e!==rn&&e!==nn&&e!==Ee&&e!==ur?he(t,Tt):(t.state=null,e===Ee?he(t,Tc):Zt))}function af(t,e){var r=e.length,n,i,a,o,s,h,l,f;if(!t||!t.state||(n=t.state,o=n.wrap,o===2||o===1&&n.status!==vn||n.lookahead))return Tt;for(o===1&&(t.adler=So(t.adler,e,r,0)),n.wrap=0,r>=n.w_size&&(o===0&&(le(n.head),n.strstart=0,n.block_start=0,n.insert=0),f=new mt.Buf8(n.w_size),mt.arraySet(f,e,r-n.w_size,n.w_size,0),e=f,r=n.w_size),s=t.avail_in,h=t.next_in,l=t.input,t.avail_in=r,t.next_in=0,t.input=e,Se(n);n.lookahead>=Z;){i=n.strstart,a=n.lookahead-(Z-1);do n.ins_h=(n.ins_h<<n.hash_shift^n.window[i+Z-1])&n.hash_mask,n.prev[i&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=i,i++;while(--a);n.strstart=i,n.lookahead=Z-1,Se(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=Z-1,n.match_available=0,t.next_in=h,t.input=l,t.avail_in=s,n.wrap=o,Zt}qt.deflateInit=ef;qt.deflateInit2=Ao;qt.deflateReset=Io;qt.deflateResetKeep=$o;qt.deflateSetHeader=tf;qt.deflate=rf;qt.deflateEnd=nf;qt.deflateSetDictionary=af;qt.deflateInfo="pako deflate (from Nodeca project)";var Te={},xn=ee,To=!0,Ro=!0;try{String.fromCharCode.apply(null,[0])}catch{To=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Ro=!1}var vr=new xn.Buf8(256);for(var se=0;se<256;se++)vr[se]=se>=252?6:se>=248?5:se>=240?4:se>=224?3:se>=192?2:1;vr[254]=vr[254]=1;Te.string2buf=function(t){var e,r,n,i,a,o=t.length,s=0;for(i=0;i<o;i++)r=t.charCodeAt(i),(r&64512)===55296&&i+1<o&&(n=t.charCodeAt(i+1),(n&64512)===56320&&(r=65536+(r-55296<<10)+(n-56320),i++)),s+=r<128?1:r<2048?2:r<65536?3:4;for(e=new xn.Buf8(s),a=0,i=0;a<s;i++)r=t.charCodeAt(i),(r&64512)===55296&&i+1<o&&(n=t.charCodeAt(i+1),(n&64512)===56320&&(r=65536+(r-55296<<10)+(n-56320),i++)),r<128?e[a++]=r:r<2048?(e[a++]=192|r>>>6,e[a++]=128|r&63):r<65536?(e[a++]=224|r>>>12,e[a++]=128|r>>>6&63,e[a++]=128|r&63):(e[a++]=240|r>>>18,e[a++]=128|r>>>12&63,e[a++]=128|r>>>6&63,e[a++]=128|r&63);return e};function Oo(t,e){if(e<65534&&(t.subarray&&Ro||!t.subarray&&To))return String.fromCharCode.apply(null,xn.shrinkBuf(t,e));for(var r="",n=0;n<e;n++)r+=String.fromCharCode(t[n]);return r}Te.buf2binstring=function(t){return Oo(t,t.length)};Te.binstring2buf=function(t){for(var e=new xn.Buf8(t.length),r=0,n=e.length;r<n;r++)e[r]=t.charCodeAt(r);return e};Te.buf2string=function(t,e){var r,n,i,a,o=e||t.length,s=new Array(o*2);for(n=0,r=0;r<o;){if(i=t[r++],i<128){s[n++]=i;continue}if(a=vr[i],a>4){s[n++]=65533,r+=a-1;continue}for(i&=a===2?31:a===3?15:7;a>1&&r<o;)i=i<<6|t[r++]&63,a--;if(a>1){s[n++]=65533;continue}i<65536?s[n++]=i:(i-=65536,s[n++]=55296|i>>10&1023,s[n++]=56320|i&1023)}return Oo(s,n)};Te.utf8border=function(t,e){var r;for(e=e||t.length,e>t.length&&(e=t.length),r=e-1;r>=0&&(t[r]&192)===128;)r--;return r<0||r===0?e:r+vr[t[r]]>e?r:e};function of(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var Co=of,dr=qt,wr=ee,li=Te,ui=Bi,sf=Co,Fo=Object.prototype.toString,cf=0,zn=4,Le=0,Yi=1,Ki=2,ff=-1,lf=0,uf=8;function Be(t){if(!(this instanceof Be))return new Be(t);this.options=wr.assign({level:ff,method:uf,chunkSize:16384,windowBits:15,memLevel:8,strategy:lf,to:""},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new sf,this.strm.avail_out=0;var r=dr.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==Le)throw new Error(ui[r]);if(e.header&&dr.deflateSetHeader(this.strm,e.header),e.dictionary){var n;if(typeof e.dictionary=="string"?n=li.string2buf(e.dictionary):Fo.call(e.dictionary)==="[object ArrayBuffer]"?n=new Uint8Array(e.dictionary):n=e.dictionary,r=dr.deflateSetDictionary(this.strm,n),r!==Le)throw new Error(ui[r]);this._dict_set=!0}}Be.prototype.push=function(t,e){var r=this.strm,n=this.options.chunkSize,i,a;if(this.ended)return!1;a=e===~~e?e:e===!0?zn:cf,typeof t=="string"?r.input=li.string2buf(t):Fo.call(t)==="[object ArrayBuffer]"?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;do{if(r.avail_out===0&&(r.output=new wr.Buf8(n),r.next_out=0,r.avail_out=n),i=dr.deflate(r,a),i!==Yi&&i!==Le)return this.onEnd(i),this.ended=!0,!1;(r.avail_out===0||r.avail_in===0&&(a===zn||a===Ki))&&(this.options.to==="string"?this.onData(li.buf2binstring(wr.shrinkBuf(r.output,r.next_out))):this.onData(wr.shrinkBuf(r.output,r.next_out)))}while((r.avail_in>0||r.avail_out===0)&&i!==Yi);return a===zn?(i=dr.deflateEnd(this.strm),this.onEnd(i),this.ended=!0,i===Le):(a===Ki&&(this.onEnd(Le),r.avail_out=0),!0)};Be.prototype.onData=function(t){this.chunks.push(t)};Be.prototype.onEnd=function(t){t===Le&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=wr.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};function $i(t,e){var r=new Be(e);if(r.push(t,!0),r.err)throw r.msg||ui[r.err];return r.result}function hf(t,e){return e=e||{},e.raw=!0,$i(t,e)}function df(t,e){return e=e||{},e.gzip=!0,$i(t,e)}kr.Deflate=Be;kr.deflate=$i;kr.deflateRaw=hf;kr.gzip=df;var $r={},Ft={},Xr=30,wf=12,pf=function(e,r){var n,i,a,o,s,h,l,f,d,p,m,g,b,E,x,$,A,B,S,U,O,k,N,T,C;n=e.state,i=e.next_in,T=e.input,a=i+(e.avail_in-5),o=e.next_out,C=e.output,s=o-(r-e.avail_out),h=o+(e.avail_out-257),l=n.dmax,f=n.wsize,d=n.whave,p=n.wnext,m=n.window,g=n.hold,b=n.bits,E=n.lencode,x=n.distcode,$=(1<<n.lenbits)-1,A=(1<<n.distbits)-1;t:do{b<15&&(g+=T[i++]<<b,b+=8,g+=T[i++]<<b,b+=8),B=E[g&$];e:for(;;){if(S=B>>>24,g>>>=S,b-=S,S=B>>>16&255,S===0)C[o++]=B&65535;else if(S&16){U=B&65535,S&=15,S&&(b<S&&(g+=T[i++]<<b,b+=8),U+=g&(1<<S)-1,g>>>=S,b-=S),b<15&&(g+=T[i++]<<b,b+=8,g+=T[i++]<<b,b+=8),B=x[g&A];r:for(;;){if(S=B>>>24,g>>>=S,b-=S,S=B>>>16&255,S&16){if(O=B&65535,S&=15,b<S&&(g+=T[i++]<<b,b+=8,b<S&&(g+=T[i++]<<b,b+=8)),O+=g&(1<<S)-1,O>l){e.msg="invalid distance too far back",n.mode=Xr;break t}if(g>>>=S,b-=S,S=o-s,O>S){if(S=O-S,S>d&&n.sane){e.msg="invalid distance too far back",n.mode=Xr;break t}if(k=0,N=m,p===0){if(k+=f-S,S<U){U-=S;do C[o++]=m[k++];while(--S);k=o-O,N=C}}else if(p<S){if(k+=f+p-S,S-=p,S<U){U-=S;do C[o++]=m[k++];while(--S);if(k=0,p<U){S=p,U-=S;do C[o++]=m[k++];while(--S);k=o-O,N=C}}}else if(k+=p-S,S<U){U-=S;do C[o++]=m[k++];while(--S);k=o-O,N=C}for(;U>2;)C[o++]=N[k++],C[o++]=N[k++],C[o++]=N[k++],U-=3;U&&(C[o++]=N[k++],U>1&&(C[o++]=N[k++]))}else{k=o-O;do C[o++]=C[k++],C[o++]=C[k++],C[o++]=C[k++],U-=3;while(U>2);U&&(C[o++]=C[k++],U>1&&(C[o++]=C[k++]))}}else if(S&64){e.msg="invalid distance code",n.mode=Xr;break t}else{B=x[(B&65535)+(g&(1<<S)-1)];continue r}break}}else if(S&64)if(S&32){n.mode=wf;break t}else{e.msg="invalid literal/length code",n.mode=Xr;break t}else{B=E[(B&65535)+(g&(1<<S)-1)];continue e}break}}while(i<a&&o<h);U=b>>3,i-=U,b-=U<<3,g&=(1<<b)-1,e.next_in=i,e.next_out=o,e.avail_in=i<a?5+(a-i):5-(i-a),e.avail_out=o<h?257+(h-o):257-(o-h),n.hold=g,n.bits=b},Vi=ee,De=15,Qi=852,Ji=592,ta=0,Mn=1,ea=2,mf=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],_f=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],gf=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],yf=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64],bf=function(e,r,n,i,a,o,s,h){var l=h.bits,f=0,d=0,p=0,m=0,g=0,b=0,E=0,x=0,$=0,A=0,B,S,U,O,k,N=null,T=0,C,P=new Vi.Buf16(De+1),z=new Vi.Buf16(De+1),G=null,ut=0,Ut,wt,Ot;for(f=0;f<=De;f++)P[f]=0;for(d=0;d<i;d++)P[r[n+d]]++;for(g=l,m=De;m>=1&&P[m]===0;m--);if(g>m&&(g=m),m===0)return a[o++]=1<<24|64<<16|0,a[o++]=1<<24|64<<16|0,h.bits=1,0;for(p=1;p<m&&P[p]===0;p++);for(g<p&&(g=p),x=1,f=1;f<=De;f++)if(x<<=1,x-=P[f],x<0)return-1;if(x>0&&(e===ta||m!==1))return-1;for(z[1]=0,f=1;f<De;f++)z[f+1]=z[f]+P[f];for(d=0;d<i;d++)r[n+d]!==0&&(s[z[r[n+d]]++]=d);if(e===ta?(N=G=s,C=19):e===Mn?(N=mf,T-=257,G=_f,ut-=257,C=256):(N=gf,G=yf,C=-1),A=0,d=0,f=p,k=o,b=g,E=0,U=-1,$=1<<g,O=$-1,e===Mn&&$>Qi||e===ea&&$>Ji)return 1;for(;;){Ut=f-E,s[d]<C?(wt=0,Ot=s[d]):s[d]>C?(wt=G[ut+s[d]],Ot=N[T+s[d]]):(wt=32+64,Ot=0),B=1<<f-E,S=1<<b,p=S;do S-=B,a[k+(A>>E)+S]=Ut<<24|wt<<16|Ot|0;while(S!==0);for(B=1<<f-1;A&B;)B>>=1;if(B!==0?(A&=B-1,A+=B):A=0,d++,--P[f]===0){if(f===m)break;f=r[n+s[d]]}if(f>g&&(A&O)!==U){for(E===0&&(E=g),k+=p,b=f-E,x=1<<b;b+E<m&&(x-=P[b+E],!(x<=0));)b++,x<<=1;if($+=1<<b,e===Mn&&$>Qi||e===ea&&$>Ji)return 1;U=A&O,a[U]=g<<24|b<<16|k-o|0}}return A!==0&&(a[k+A]=f-E<<24|64<<16|0),h.bits=g,0},Et=ee,hi=Eo,zt=ko,vf=pf,pr=bf,xf=0,No=1,Uo=2,ra=4,Ef=5,Yr=6,$e=0,kf=1,Sf=2,Rt=-2,Do=-3,Po=-4,Bf=-5,na=8,zo=1,ia=2,aa=3,oa=4,sa=5,ca=6,fa=7,la=8,ua=9,ha=10,cn=11,Yt=12,jn=13,da=14,Ln=15,wa=16,pa=17,ma=18,_a=19,Kr=20,Vr=21,ga=22,ya=23,ba=24,va=25,xa=26,Hn=27,Ea=28,ka=29,tt=30,Mo=31,$f=32,If=852,Af=592,Tf=15,Rf=Tf;function Sa(t){return(t>>>24&255)+(t>>>8&65280)+((t&65280)<<8)+((t&255)<<24)}function Of(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Et.Buf16(320),this.work=new Et.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function jo(t){var e;return!t||!t.state?Rt:(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=e.wrap&1),e.mode=zo,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Et.Buf32(If),e.distcode=e.distdyn=new Et.Buf32(Af),e.sane=1,e.back=-1,$e)}function Lo(t){var e;return!t||!t.state?Rt:(e=t.state,e.wsize=0,e.whave=0,e.wnext=0,jo(t))}function Ho(t,e){var r,n;return!t||!t.state||(n=t.state,e<0?(r=0,e=-e):(r=(e>>4)+1,e<48&&(e&=15)),e&&(e<8||e>15))?Rt:(n.window!==null&&n.wbits!==e&&(n.window=null),n.wrap=r,n.wbits=e,Lo(t))}function Zo(t,e){var r,n;return t?(n=new Of,t.state=n,n.window=null,r=Ho(t,e),r!==$e&&(t.state=null),r):Rt}function Cf(t){return Zo(t,Rf)}var Ba=!0,Zn,Gn;function Ff(t){if(Ba){var e;for(Zn=new Et.Buf32(512),Gn=new Et.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(pr(No,t.lens,0,288,Zn,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;pr(Uo,t.lens,0,32,Gn,0,t.work,{bits:5}),Ba=!1}t.lencode=Zn,t.lenbits=9,t.distcode=Gn,t.distbits=5}function Go(t,e,r,n){var i,a=t.state;return a.window===null&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Et.Buf8(a.wsize)),n>=a.wsize?(Et.arraySet(a.window,e,r-a.wsize,a.wsize,0),a.wnext=0,a.whave=a.wsize):(i=a.wsize-a.wnext,i>n&&(i=n),Et.arraySet(a.window,e,r-n,i,a.wnext),n-=i,n?(Et.arraySet(a.window,e,r-n,n,0),a.wnext=n,a.whave=a.wsize):(a.wnext+=i,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=i))),0}function Nf(t,e){var r,n,i,a,o,s,h,l,f,d,p,m,g,b,E=0,x,$,A,B,S,U,O,k,N=new Et.Buf8(4),T,C,P=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&t.avail_in!==0)return Rt;r=t.state,r.mode===Yt&&(r.mode=jn),o=t.next_out,i=t.output,h=t.avail_out,a=t.next_in,n=t.input,s=t.avail_in,l=r.hold,f=r.bits,d=s,p=h,k=$e;t:for(;;)switch(r.mode){case zo:if(r.wrap===0){r.mode=jn;break}for(;f<16;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(r.wrap&2&&l===35615){r.check=0,N[0]=l&255,N[1]=l>>>8&255,r.check=zt(r.check,N,2,0),l=0,f=0,r.mode=ia;break}if(r.flags=0,r.head&&(r.head.done=!1),!(r.wrap&1)||(((l&255)<<8)+(l>>8))%31){t.msg="incorrect header check",r.mode=tt;break}if((l&15)!==na){t.msg="unknown compression method",r.mode=tt;break}if(l>>>=4,f-=4,O=(l&15)+8,r.wbits===0)r.wbits=O;else if(O>r.wbits){t.msg="invalid window size",r.mode=tt;break}r.dmax=1<<O,t.adler=r.check=1,r.mode=l&512?ha:Yt,l=0,f=0;break;case ia:for(;f<16;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(r.flags=l,(r.flags&255)!==na){t.msg="unknown compression method",r.mode=tt;break}if(r.flags&57344){t.msg="unknown header flags set",r.mode=tt;break}r.head&&(r.head.text=l>>8&1),r.flags&512&&(N[0]=l&255,N[1]=l>>>8&255,r.check=zt(r.check,N,2,0)),l=0,f=0,r.mode=aa;case aa:for(;f<32;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}r.head&&(r.head.time=l),r.flags&512&&(N[0]=l&255,N[1]=l>>>8&255,N[2]=l>>>16&255,N[3]=l>>>24&255,r.check=zt(r.check,N,4,0)),l=0,f=0,r.mode=oa;case oa:for(;f<16;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}r.head&&(r.head.xflags=l&255,r.head.os=l>>8),r.flags&512&&(N[0]=l&255,N[1]=l>>>8&255,r.check=zt(r.check,N,2,0)),l=0,f=0,r.mode=sa;case sa:if(r.flags&1024){for(;f<16;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}r.length=l,r.head&&(r.head.extra_len=l),r.flags&512&&(N[0]=l&255,N[1]=l>>>8&255,r.check=zt(r.check,N,2,0)),l=0,f=0}else r.head&&(r.head.extra=null);r.mode=ca;case ca:if(r.flags&1024&&(m=r.length,m>s&&(m=s),m&&(r.head&&(O=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),Et.arraySet(r.head.extra,n,a,m,O)),r.flags&512&&(r.check=zt(r.check,n,m,a)),s-=m,a+=m,r.length-=m),r.length))break t;r.length=0,r.mode=fa;case fa:if(r.flags&2048){if(s===0)break t;m=0;do O=n[a+m++],r.head&&O&&r.length<65536&&(r.head.name+=String.fromCharCode(O));while(O&&m<s);if(r.flags&512&&(r.check=zt(r.check,n,m,a)),s-=m,a+=m,O)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=la;case la:if(r.flags&4096){if(s===0)break t;m=0;do O=n[a+m++],r.head&&O&&r.length<65536&&(r.head.comment+=String.fromCharCode(O));while(O&&m<s);if(r.flags&512&&(r.check=zt(r.check,n,m,a)),s-=m,a+=m,O)break t}else r.head&&(r.head.comment=null);r.mode=ua;case ua:if(r.flags&512){for(;f<16;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(l!==(r.check&65535)){t.msg="header crc mismatch",r.mode=tt;break}l=0,f=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=Yt;break;case ha:for(;f<32;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}t.adler=r.check=Sa(l),l=0,f=0,r.mode=cn;case cn:if(r.havedict===0)return t.next_out=o,t.avail_out=h,t.next_in=a,t.avail_in=s,r.hold=l,r.bits=f,Sf;t.adler=r.check=1,r.mode=Yt;case Yt:if(e===Ef||e===Yr)break t;case jn:if(r.last){l>>>=f&7,f-=f&7,r.mode=Hn;break}for(;f<3;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}switch(r.last=l&1,l>>>=1,f-=1,l&3){case 0:r.mode=da;break;case 1:if(Ff(r),r.mode=Kr,e===Yr){l>>>=2,f-=2;break t}break;case 2:r.mode=pa;break;case 3:t.msg="invalid block type",r.mode=tt}l>>>=2,f-=2;break;case da:for(l>>>=f&7,f-=f&7;f<32;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if((l&65535)!==(l>>>16^65535)){t.msg="invalid stored block lengths",r.mode=tt;break}if(r.length=l&65535,l=0,f=0,r.mode=Ln,e===Yr)break t;case Ln:r.mode=wa;case wa:if(m=r.length,m){if(m>s&&(m=s),m>h&&(m=h),m===0)break t;Et.arraySet(i,n,a,m,o),s-=m,a+=m,h-=m,o+=m,r.length-=m;break}r.mode=Yt;break;case pa:for(;f<14;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(r.nlen=(l&31)+257,l>>>=5,f-=5,r.ndist=(l&31)+1,l>>>=5,f-=5,r.ncode=(l&15)+4,l>>>=4,f-=4,r.nlen>286||r.ndist>30){t.msg="too many length or distance symbols",r.mode=tt;break}r.have=0,r.mode=ma;case ma:for(;r.have<r.ncode;){for(;f<3;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}r.lens[P[r.have++]]=l&7,l>>>=3,f-=3}for(;r.have<19;)r.lens[P[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,T={bits:r.lenbits},k=pr(xf,r.lens,0,19,r.lencode,0,r.work,T),r.lenbits=T.bits,k){t.msg="invalid code lengths set",r.mode=tt;break}r.have=0,r.mode=_a;case _a:for(;r.have<r.nlen+r.ndist;){for(;E=r.lencode[l&(1<<r.lenbits)-1],x=E>>>24,$=E>>>16&255,A=E&65535,!(x<=f);){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(A<16)l>>>=x,f-=x,r.lens[r.have++]=A;else{if(A===16){for(C=x+2;f<C;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(l>>>=x,f-=x,r.have===0){t.msg="invalid bit length repeat",r.mode=tt;break}O=r.lens[r.have-1],m=3+(l&3),l>>>=2,f-=2}else if(A===17){for(C=x+3;f<C;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}l>>>=x,f-=x,O=0,m=3+(l&7),l>>>=3,f-=3}else{for(C=x+7;f<C;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}l>>>=x,f-=x,O=0,m=11+(l&127),l>>>=7,f-=7}if(r.have+m>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=tt;break}for(;m--;)r.lens[r.have++]=O}}if(r.mode===tt)break;if(r.lens[256]===0){t.msg="invalid code -- missing end-of-block",r.mode=tt;break}if(r.lenbits=9,T={bits:r.lenbits},k=pr(No,r.lens,0,r.nlen,r.lencode,0,r.work,T),r.lenbits=T.bits,k){t.msg="invalid literal/lengths set",r.mode=tt;break}if(r.distbits=6,r.distcode=r.distdyn,T={bits:r.distbits},k=pr(Uo,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,T),r.distbits=T.bits,k){t.msg="invalid distances set",r.mode=tt;break}if(r.mode=Kr,e===Yr)break t;case Kr:r.mode=Vr;case Vr:if(s>=6&&h>=258){t.next_out=o,t.avail_out=h,t.next_in=a,t.avail_in=s,r.hold=l,r.bits=f,vf(t,p),o=t.next_out,i=t.output,h=t.avail_out,a=t.next_in,n=t.input,s=t.avail_in,l=r.hold,f=r.bits,r.mode===Yt&&(r.back=-1);break}for(r.back=0;E=r.lencode[l&(1<<r.lenbits)-1],x=E>>>24,$=E>>>16&255,A=E&65535,!(x<=f);){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if($&&!($&240)){for(B=x,S=$,U=A;E=r.lencode[U+((l&(1<<B+S)-1)>>B)],x=E>>>24,$=E>>>16&255,A=E&65535,!(B+x<=f);){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}l>>>=B,f-=B,r.back+=B}if(l>>>=x,f-=x,r.back+=x,r.length=A,$===0){r.mode=xa;break}if($&32){r.back=-1,r.mode=Yt;break}if($&64){t.msg="invalid literal/length code",r.mode=tt;break}r.extra=$&15,r.mode=ga;case ga:if(r.extra){for(C=r.extra;f<C;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,f-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=ya;case ya:for(;E=r.distcode[l&(1<<r.distbits)-1],x=E>>>24,$=E>>>16&255,A=E&65535,!(x<=f);){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(!($&240)){for(B=x,S=$,U=A;E=r.distcode[U+((l&(1<<B+S)-1)>>B)],x=E>>>24,$=E>>>16&255,A=E&65535,!(B+x<=f);){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}l>>>=B,f-=B,r.back+=B}if(l>>>=x,f-=x,r.back+=x,$&64){t.msg="invalid distance code",r.mode=tt;break}r.offset=A,r.extra=$&15,r.mode=ba;case ba:if(r.extra){for(C=r.extra;f<C;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,f-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=tt;break}r.mode=va;case va:if(h===0)break t;if(m=p-h,r.offset>m){if(m=r.offset-m,m>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=tt;break}m>r.wnext?(m-=r.wnext,g=r.wsize-m):g=r.wnext-m,m>r.length&&(m=r.length),b=r.window}else b=i,g=o-r.offset,m=r.length;m>h&&(m=h),h-=m,r.length-=m;do i[o++]=b[g++];while(--m);r.length===0&&(r.mode=Vr);break;case xa:if(h===0)break t;i[o++]=r.length,h--,r.mode=Vr;break;case Hn:if(r.wrap){for(;f<32;){if(s===0)break t;s--,l|=n[a++]<<f,f+=8}if(p-=h,t.total_out+=p,r.total+=p,p&&(t.adler=r.check=r.flags?zt(r.check,i,p,o-p):hi(r.check,i,p,o-p)),p=h,(r.flags?l:Sa(l))!==r.check){t.msg="incorrect data check",r.mode=tt;break}l=0,f=0}r.mode=Ea;case Ea:if(r.wrap&&r.flags){for(;f<32;){if(s===0)break t;s--,l+=n[a++]<<f,f+=8}if(l!==(r.total&4294967295)){t.msg="incorrect length check",r.mode=tt;break}l=0,f=0}r.mode=ka;case ka:k=kf;break t;case tt:k=Do;break t;case Mo:return Po;case $f:default:return Rt}return t.next_out=o,t.avail_out=h,t.next_in=a,t.avail_in=s,r.hold=l,r.bits=f,(r.wsize||p!==t.avail_out&&r.mode<tt&&(r.mode<Hn||e!==ra))&&Go(t,t.output,t.next_out,p-t.avail_out),d-=t.avail_in,p-=t.avail_out,t.total_in+=d,t.total_out+=p,r.total+=p,r.wrap&&p&&(t.adler=r.check=r.flags?zt(r.check,i,p,t.next_out-p):hi(r.check,i,p,t.next_out-p)),t.data_type=r.bits+(r.last?64:0)+(r.mode===Yt?128:0)+(r.mode===Kr||r.mode===Ln?256:0),(d===0&&p===0||e===ra)&&k===$e&&(k=Bf),k}function Uf(t){if(!t||!t.state)return Rt;var e=t.state;return e.window&&(e.window=null),t.state=null,$e}function Df(t,e){var r;return!t||!t.state||(r=t.state,!(r.wrap&2))?Rt:(r.head=e,e.done=!1,$e)}function Pf(t,e){var r=e.length,n,i,a;return!t||!t.state||(n=t.state,n.wrap!==0&&n.mode!==cn)?Rt:n.mode===cn&&(i=1,i=hi(i,e,r,0),i!==n.check)?Do:(a=Go(t,e,r,r),a?(n.mode=Mo,Po):(n.havedict=1,$e))}Ft.inflateReset=Lo;Ft.inflateReset2=Ho;Ft.inflateResetKeep=jo;Ft.inflateInit=Cf;Ft.inflateInit2=Zo;Ft.inflate=Nf;Ft.inflateEnd=Uf;Ft.inflateGetHeader=Df;Ft.inflateSetDictionary=Pf;Ft.inflateInfo="pako inflate (from Nodeca project)";var Wo={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};function zf(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var Mf=zf,He=Ft,mr=ee,an=Te,at=Wo,di=Bi,jf=Co,Lf=Mf,qo=Object.prototype.toString;function Ie(t){if(!(this instanceof Ie))return new Ie(t);this.options=mr.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,e.windowBits===0&&(e.windowBits=-15)),e.windowBits>=0&&e.windowBits<16&&!(t&&t.windowBits)&&(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&(e.windowBits&15||(e.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new jf,this.strm.avail_out=0;var r=He.inflateInit2(this.strm,e.windowBits);if(r!==at.Z_OK)throw new Error(di[r]);if(this.header=new Lf,He.inflateGetHeader(this.strm,this.header),e.dictionary&&(typeof e.dictionary=="string"?e.dictionary=an.string2buf(e.dictionary):qo.call(e.dictionary)==="[object ArrayBuffer]"&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(r=He.inflateSetDictionary(this.strm,e.dictionary),r!==at.Z_OK)))throw new Error(di[r])}Ie.prototype.push=function(t,e){var r=this.strm,n=this.options.chunkSize,i=this.options.dictionary,a,o,s,h,l,f=!1;if(this.ended)return!1;o=e===~~e?e:e===!0?at.Z_FINISH:at.Z_NO_FLUSH,typeof t=="string"?r.input=an.binstring2buf(t):qo.call(t)==="[object ArrayBuffer]"?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;do{if(r.avail_out===0&&(r.output=new mr.Buf8(n),r.next_out=0,r.avail_out=n),a=He.inflate(r,at.Z_NO_FLUSH),a===at.Z_NEED_DICT&&i&&(a=He.inflateSetDictionary(this.strm,i)),a===at.Z_BUF_ERROR&&f===!0&&(a=at.Z_OK,f=!1),a!==at.Z_STREAM_END&&a!==at.Z_OK)return this.onEnd(a),this.ended=!0,!1;r.next_out&&(r.avail_out===0||a===at.Z_STREAM_END||r.avail_in===0&&(o===at.Z_FINISH||o===at.Z_SYNC_FLUSH))&&(this.options.to==="string"?(s=an.utf8border(r.output,r.next_out),h=r.next_out-s,l=an.buf2string(r.output,s),r.next_out=h,r.avail_out=n-h,h&&mr.arraySet(r.output,r.output,s,h,0),this.onData(l)):this.onData(mr.shrinkBuf(r.output,r.next_out))),r.avail_in===0&&r.avail_out===0&&(f=!0)}while((r.avail_in>0||r.avail_out===0)&&a!==at.Z_STREAM_END);return a===at.Z_STREAM_END&&(o=at.Z_FINISH),o===at.Z_FINISH?(a=He.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===at.Z_OK):(o===at.Z_SYNC_FLUSH&&(this.onEnd(at.Z_OK),r.avail_out=0),!0)};Ie.prototype.onData=function(t){this.chunks.push(t)};Ie.prototype.onEnd=function(t){t===at.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=mr.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};function Ii(t,e){var r=new Ie(e);if(r.push(t,!0),r.err)throw r.msg||di[r.err];return r.result}function Hf(t,e){return e=e||{},e.raw=!0,Ii(t,e)}$r.Inflate=Ie;$r.inflate=Ii;$r.inflateRaw=Hf;$r.ungzip=Ii;var Zf=ee.assign,Gf=kr,Wf=$r,qf=Wo,Xo={};Zf(Xo,Gf,Wf,qf);var Xf=Xo;const Ai=ge(Xf),$a=(t,e)=>function(...r){const n=e.promiseModule;return new n((i,a)=>{e.multiArgs?r.push((...o)=>{e.errorFirst?o[0]?a(o):(o.shift(),i(o)):i(o)}):e.errorFirst?r.push((o,s)=>{o?a(o):i(s)}):r.push(i),t.apply(this,r)})};var Yf=(t,e)=>{e=Object.assign({exclude:[/.+(Sync|Stream)$/],errorFirst:!0,promiseModule:Promise},e);const r=typeof t;if(!(t!==null&&(r==="object"||r==="function")))throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${t===null?"null":r}\``);const n=a=>{const o=s=>typeof s=="string"?a===s:s.test(a);return e.include?e.include.some(o):!e.exclude.some(o)};let i;r==="function"?i=function(...a){return e.excludeMain?t(...a):$a(t,e).apply(this,a)}:i=Object.create(Object.getPrototypeOf(t));for(const a in t){const o=t[a];i[a]=typeof o=="function"&&n(a)?$a(o,e):o}return i};const Wn=ge(Yf);function Ia(t){return Array.isArray(t)?t:[t]}const Yo="",Aa=" ",qn="\\",Kf=/^\s+$/,Vf=/(?:[^\\]|^)\\$/,Qf=/^\\!/,Jf=/^\\#/,tl=/\r?\n/g,el=/^\.*\/|^\.+$/,Xn="/";let Ko="node-ignore";typeof Symbol<"u"&&(Ko=Symbol.for("node-ignore"));const Ta=Ko,rl=(t,e,r)=>Object.defineProperty(t,e,{value:r}),nl=/([0-z])-([0-z])/g,Vo=()=>!1,il=t=>t.replace(nl,(e,r,n)=>r.charCodeAt(0)<=n.charCodeAt(0)?e:Yo),al=t=>{const{length:e}=t;return t.slice(0,e-e%2)},ol=[[/\\?\s+$/,t=>t.indexOf("\\")===0?Aa:Yo],[/\\\s/g,()=>Aa],[/[\\$.|*+(){^]/g,t=>`\\${t}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(t,e,r)=>e+6<r.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)(\\\*)+(?=.+)/g,(t,e,r)=>{const n=r.replace(/\\\*/g,"[^\\/]*");return e+n}],[/\\\\\\(?=[$.|*+(){^])/g,()=>qn],[/\\\\/g,()=>qn],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(t,e,r,n,i)=>e===qn?`\\[${r}${al(n)}${i}`:i==="]"&&n.length%2===0?`[${il(r)}${n}]`:"[]"],[/(?:[^*])$/,t=>/\/$/.test(t)?`${t}$`:`${t}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(t,e)=>`${e?`${e}[^/]+`:"[^/]*"}(?=$|\\/$)`]],Ra=Object.create(null),sl=(t,e)=>{let r=Ra[t];return r||(r=ol.reduce((n,i)=>n.replace(i[0],i[1].bind(t)),t),Ra[t]=r),e?new RegExp(r,"i"):new RegExp(r)},Ti=t=>typeof t=="string",cl=t=>t&&Ti(t)&&!Kf.test(t)&&!Vf.test(t)&&t.indexOf("#")!==0,fl=t=>t.split(tl);class ll{constructor(e,r,n,i){this.origin=e,this.pattern=r,this.negative=n,this.regex=i}}const ul=(t,e)=>{const r=t;let n=!1;t.indexOf("!")===0&&(n=!0,t=t.substr(1)),t=t.replace(Qf,"!").replace(Jf,"#");const i=sl(t,e);return new ll(r,t,n,i)},hl=(t,e)=>{throw new e(t)},Qt=(t,e,r)=>Ti(t)?t?Qt.isNotRelative(t)?r(`path should be a \`path.relative()\`d string, but got "${e}"`,RangeError):!0:r("path must not be empty",TypeError):r(`path must be a string, but got \`${e}\``,TypeError),Qo=t=>el.test(t);Qt.isNotRelative=Qo;Qt.convert=t=>t;class dl{constructor({ignorecase:e=!0,ignoreCase:r=e,allowRelativePaths:n=!1}={}){rl(this,Ta,!0),this._rules=[],this._ignoreCase=r,this._allowRelativePaths=n,this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(e){if(e&&e[Ta]){this._rules=this._rules.concat(e._rules),this._added=!0;return}if(cl(e)){const r=ul(e,this._ignoreCase);this._added=!0,this._rules.push(r)}}add(e){return this._added=!1,Ia(Ti(e)?fl(e):e).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(e){return this.add(e)}_testOne(e,r){let n=!1,i=!1;return this._rules.forEach(a=>{const{negative:o}=a;if(i===o&&n!==i||o&&!n&&!i&&!r)return;a.regex.test(e)&&(n=!o,i=o)}),{ignored:n,unignored:i}}_test(e,r,n,i){const a=e&&Qt.convert(e);return Qt(a,e,this._allowRelativePaths?Vo:hl),this._t(a,r,n,i)}_t(e,r,n,i){if(e in r)return r[e];if(i||(i=e.split(Xn)),i.pop(),!i.length)return r[e]=this._testOne(e,n);const a=this._t(i.join(Xn)+Xn,r,n,i);return r[e]=a.ignored?a:this._testOne(e,n)}ignores(e){return this._test(e,this._ignoreCache,!1).ignored}createFilter(){return e=>!this.ignores(e)}filter(e){return Ia(e).filter(this.createFilter())}test(e){return this._test(e,this._testCache,!0)}}const fn=t=>new dl(t),wl=t=>Qt(t&&Qt.convert(t),t,Vo);fn.isPathValid=wl;fn.default=fn;var pl=fn;if(typeof process<"u"&&(process.env&&{}.IGNORE_TEST_WIN32||process.platform==="win32")){const t=r=>/^\\\\\?\\/.test(r)||/["<>|\u0000-\u001F]+/u.test(r)?r:r.replace(/\\/g,"/");Qt.convert=t;const e=/^[a-z]:\//i;Qt.isNotRelative=r=>e.test(r)||Qo(r)}const ml=ge(pl);function _l(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function Mt(t,e,r){return e=e instanceof RegExp?e:new RegExp(_l(e),"g"),t.replace(e,r)}var gl={clean:function(e){if(typeof e!="string")throw new Error("Expected a string, received: "+e);return e=Mt(e,"./","/"),e=Mt(e,"..","."),e=Mt(e," ","-"),e=Mt(e,/^[~^:?*\\\-]/g,""),e=Mt(e,/[~^:?*\\]/g,"-"),e=Mt(e,/[~^:?*\\\-]$/g,""),e=Mt(e,"@{","-"),e=Mt(e,/\.$/g,""),e=Mt(e,/\/$/g,""),e=Mt(e,/\.lock$/g,""),e}},yl=gl;const Wt=ge(yl);var bl=function(t,e){var r=t,n=e,i=r.length,a=n.length,o=!1,s=null,h=i+1,l=[],f=[],d=[],p="",m=-1,g=0,b=1,E,x,$=function(){i>=a&&(E=r,x=i,r=n,n=E,i=a,a=x,o=!0,h=i+1)},A=function(O,k,N){return{x:O,y:k,k:N}},B=function(O,k){return{elem:O,t:k}},S=function(O,k,N){var T,C,P;for(k>N?T=l[O-1+h]:T=l[O+1+h],P=Math.max(k,N),C=P-O;C<i&&P<a&&r[C]===n[P];)++C,++P;return l[O+h]=f.length,f[f.length]=new A(C,P,T),P},U=function(O){var k,N,T;for(k=N=0,T=O.length-1;T>=0;--T)for(;k<O[T].x||N<O[T].y;)O[T].y-O[T].x>N-k?(o?d[d.length]=new B(n[N],m):d[d.length]=new B(n[N],b),++N):O[T].y-O[T].x<N-k?(o?d[d.length]=new B(r[k],b):d[d.length]=new B(r[k],m),++k):(d[d.length]=new B(r[k],g),p+=r[k],++k,++N)};return $(),{SES_DELETE:-1,SES_COMMON:0,SES_ADD:1,editdistance:function(){return s},getlcs:function(){return p},getses:function(){return d},compose:function(){var O,k,N,T,C,P,z,G;for(O=a-i,k=i+a+3,N={},z=0;z<k;++z)N[z]=-1,l[z]=-1;T=-1;do{for(++T,G=-T;G<=O-1;++G)N[G+h]=S(G,N[G-1+h]+1,N[G+1+h]);for(G=O+T;G>=O+1;--G)N[G+h]=S(G,N[G-1+h]+1,N[G+1+h]);N[O+h]=S(O,N[O-1+h]+1,N[O+1+h])}while(N[O+h]!==a);for(s=O+2*T,C=l[O+h],P=[];C!==-1;)P[P.length]=new A(f[C].x,f[C].y,null),C=f[C].k;U(P)}}},vl=bl;function xl(t,e){var r=new vl(t,e);r.compose();for(var n=r.getses(),i,a,o=t.length-1,s=e.length-1,h=n.length-1;h>=0;--h)n[h].t===r.SES_COMMON?(a?(a.chain={file1index:o,file2index:s,chain:null},a=a.chain):(i={file1index:o,file2index:s,chain:null},a=i),o--,s--):n[h].t===r.SES_DELETE?o--:n[h].t===r.SES_ADD&&s--;var l={file1index:-1,file2index:-1,chain:null};return a?(a.chain=l,i):l}function Oa(t,e){for(var r=[],n=t.length,i=e.length,a=xl(t,e);a!==null;a=a.chain){var o=n-a.file1index-1,s=i-a.file2index-1;n=a.file1index,i=a.file2index,(o||s)&&r.push({file1:[n+1,o],file2:[i+1,s]})}return r.reverse(),r}function El(t,e,r){var n,i=Oa(e,t),a=Oa(e,r),o=[];function s(z,G){o.push([z.file1[0],G,z.file1[1],z.file2[0],z.file2[1]])}for(n=0;n<i.length;n++)s(i[n],0);for(n=0;n<a.length;n++)s(a[n],2);o.sort(function(z,G){return z[0]-G[0]});var h=[],l=0;function f(z){z>l&&(h.push([1,l,z-l]),l=z)}for(var d=0;d<o.length;d++){for(var p=d,m=o[d],g=m[0],b=g+m[2];d<o.length-1;){var E=o[d+1],x=E[0];if(x>b)break;b=Math.max(b,x+E[2]),d++}if(f(g),p==d)m[4]>0&&h.push([m[1],m[3],m[4]]);else{var $={0:[t.length,-1,e.length,-1],2:[r.length,-1,e.length,-1]};for(n=p;n<=d;n++){m=o[n];var A=m[1],B=$[A],S=m[0],U=S+m[2],O=m[3],k=O+m[4];B[0]=Math.min(O,B[0]),B[1]=Math.max(k,B[1]),B[2]=Math.min(S,B[2]),B[3]=Math.max(U,B[3])}var N=$[0][0]+(g-$[0][2]),T=$[0][1]+(b-$[0][3]),C=$[2][0]+(g-$[2][2]),P=$[2][1]+(b-$[2][3]);h.push([-1,N,T-N,g,b-g,C,P-C])}l=b}return f(e.length),h}function kl(t,e,r){var n=[],i=[t,e,r],a=El(t,e,r),o=[];function s(){o.length&&n.push({ok:o}),o=[]}function h(m){for(var g=0;g<m.length;g++)o.push(m[g])}function l(m){if(m[2]!=m[6])return!0;for(var g=m[1],b=m[5],E=0;E<m[2];E++)if(t[E+g]!=r[E+b])return!0;return!1}for(var f=0;f<a.length;f++){var d=a[f],p=d[0];p==-1?l(d)?(s(),n.push({conflict:{a:t.slice(d[1],d[1]+d[2]),aIndex:d[1],o:e.slice(d[3],d[3]+d[4]),oIndex:d[3],b:r.slice(d[5],d[5]+d[6]),bIndex:d[5]}})):h(i[0].slice(d[1],d[1]+d[2])):h(i[p].slice(d[1],d[1]+d[2]))}return s(),n}var Sl=kl;const Bl=ge(Sl);class W extends Error{constructor(e){super(e),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(e){const r=new W(e.message);return r.code=e.code,r.data=e.data,r.caller=e.caller,r.stack=e.stack,r}get isIsomorphicGitError(){return!0}}class Ir extends W{constructor(e){super(`Modifying the index is not possible because you have unmerged files: ${e.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=Ir.code,this.data={filepaths:e}}}Ir.code="UnmergedPathsError";class j extends W{constructor(e){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${e}`),this.code=this.name=j.code,this.data={message:e}}}j.code="InternalError";class tr extends W{constructor(e){super(`The filepath "${e}" contains unsafe character sequences`),this.code=this.name=tr.code,this.data={filepath:e}}}tr.code="UnsafeFilepathError";class Gt{constructor(e){this.buffer=e,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(e){this._start=e}slice(e){const r=this.buffer.slice(this._start,this._start+e);return this._start+=e,r}toString(e,r){const n=this.buffer.toString(e,this._start,this._start+r);return this._start+=r,n}write(e,r,n){const i=this.buffer.write(e,this._start,r,n);return this._start+=r,i}copy(e,r,n){const i=e.copy(this.buffer,this._start,r,n);return this._start+=i,i}readUInt8(){const e=this.buffer.readUInt8(this._start);return this._start+=1,e}writeUInt8(e){const r=this.buffer.writeUInt8(e,this._start);return this._start+=1,r}readUInt16BE(){const e=this.buffer.readUInt16BE(this._start);return this._start+=2,e}writeUInt16BE(e){const r=this.buffer.writeUInt16BE(e,this._start);return this._start+=2,r}readUInt32BE(){const e=this.buffer.readUInt32BE(this._start);return this._start+=4,e}writeUInt32BE(e){const r=this.buffer.writeUInt32BE(e,this._start);return this._start+=4,r}}function En(t,e){return-(t<e)||+(t>e)}function Jo(t,e){return En(t.path,e.path)}function ts(t){let e=t>0?t>>12:0;e!==4&&e!==8&&e!==10&&e!==14&&(e=8);let r=t&511;return r&73?r=493:r=420,e!==8&&(r=0),(e<<12)+r}const jt=2**32;function Ca(t,e,r,n){if(t!==void 0&&e!==void 0)return[t,e];r===void 0&&(r=n.valueOf());const i=Math.floor(r/1e3),a=(r-i*1e3)*1e6;return[i,a]}function Ze(t){const[e,r]=Ca(t.ctimeSeconds,t.ctimeNanoseconds,t.ctimeMs,t.ctime),[n,i]=Ca(t.mtimeSeconds,t.mtimeNanoseconds,t.mtimeMs,t.mtime);return{ctimeSeconds:e%jt,ctimeNanoseconds:r%jt,mtimeSeconds:n%jt,mtimeNanoseconds:i%jt,dev:t.dev%jt,ino:t.ino%jt,mode:ts(t.mode%jt),uid:t.uid%jt,gid:t.gid%jt,size:t.size>-1?t.size%jt:0}}function $l(t){let e="";for(const r of new Uint8Array(t))r<16&&(e+="0"),e+=r.toString(16);return e}let Yn=null;async function Jt(t){return Yn===null&&(Yn=await Al()),Yn?es(t):Il(t)}function Il(t){return new ao().update(t).digest("hex")}async function es(t){const e=await crypto.subtle.digest("SHA-1",t);return $l(e)}async function Al(){try{if(await es(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709")return!0}catch{}return!1}function Tl(t){return{assumeValid:!!(t&32768),extended:!!(t&16384),stage:(t&12288)>>12,nameLength:t&4095}}function Rl(t){const e=t.flags;return e.extended=!1,e.nameLength=Math.min(Buffer.from(t.path).length,4095),(e.assumeValid?32768:0)+(e.extended?16384:0)+((e.stage&3)<<12)+(e.nameLength&4095)}class ve{constructor(e,r){this._dirty=!1,this._unmergedPaths=r||new Set,this._entries=e||new Map}_addEntry(e){if(e.flags.stage===0)e.stages=[e],this._entries.set(e.path,e),this._unmergedPaths.delete(e.path);else{let r=this._entries.get(e.path);r||(this._entries.set(e.path,e),r=e),r.stages[e.flags.stage]=e,this._unmergedPaths.add(e.path)}}static async from(e){if(Buffer.isBuffer(e))return ve.fromBuffer(e);if(e===null)return new ve(null);throw new j("invalid type passed to GitIndex.from")}static async fromBuffer(e){if(e.length===0)throw new j("Index file is empty (.git/index)");const r=new ve,n=new Gt(e),i=n.toString("utf8",4);if(i!=="DIRC")throw new j(`Invalid dircache magic file number: ${i}`);const a=await Jt(e.slice(0,-20)),o=e.slice(-20).toString("hex");if(o!==a)throw new j(`Invalid checksum in GitIndex buffer: expected ${o} but saw ${a}`);const s=n.readUInt32BE();if(s!==2)throw new j(`Unsupported dircache version: ${s}`);const h=n.readUInt32BE();let l=0;for(;!n.eof()&&l<h;){const f={};f.ctimeSeconds=n.readUInt32BE(),f.ctimeNanoseconds=n.readUInt32BE(),f.mtimeSeconds=n.readUInt32BE(),f.mtimeNanoseconds=n.readUInt32BE(),f.dev=n.readUInt32BE(),f.ino=n.readUInt32BE(),f.mode=n.readUInt32BE(),f.uid=n.readUInt32BE(),f.gid=n.readUInt32BE(),f.size=n.readUInt32BE(),f.oid=n.slice(20).toString("hex");const d=n.readUInt16BE();f.flags=Tl(d);const p=e.indexOf(0,n.tell()+1)-n.tell();if(p<1)throw new j(`Got a path length of: ${p}`);if(f.path=n.toString("utf8",p),f.path.includes("..\\")||f.path.includes("../"))throw new tr(f.path);let m=8-(n.tell()-12)%8;for(m===0&&(m=8);m--;){const g=n.readUInt8();if(g!==0)throw new j(`Expected 1-8 null characters but got '${g}' after ${f.path}`);if(n.eof())throw new j("Unexpected end of file")}f.stages=[],r._addEntry(f),l++}return r}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(Jo)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(e=>e.stages.length>1?e.stages.filter(r=>r):e)}*[Symbol.iterator](){for(const e of this.entries)yield e}insert({filepath:e,stats:r,oid:n,stage:i=0}){r||(r={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),r=Ze(r);const a=Buffer.from(e),o={ctimeSeconds:r.ctimeSeconds,ctimeNanoseconds:r.ctimeNanoseconds,mtimeSeconds:r.mtimeSeconds,mtimeNanoseconds:r.mtimeNanoseconds,dev:r.dev,ino:r.ino,mode:r.mode||33188,uid:r.uid,gid:r.gid,size:r.size,path:e,oid:n,flags:{assumeValid:!1,extended:!1,stage:i,nameLength:a.length<4095?a.length:4095},stages:[]};this._addEntry(o),this._dirty=!0}delete({filepath:e}){if(this._entries.has(e))this._entries.delete(e);else for(const r of this._entries.keys())r.startsWith(e+"/")&&this._entries.delete(r);this._unmergedPaths.has(e)&&this._unmergedPaths.delete(e),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:e}){return this._entries.has(e)}render(){return this.entries.map(e=>`${e.mode.toString(8)} ${e.oid}    ${e.path}`).join(`
`)}static async _entryToBuffer(e){const r=Buffer.from(e.path),n=Math.ceil((62+r.length+1)/8)*8,i=Buffer.alloc(n),a=new Gt(i),o=Ze(e);return a.writeUInt32BE(o.ctimeSeconds),a.writeUInt32BE(o.ctimeNanoseconds),a.writeUInt32BE(o.mtimeSeconds),a.writeUInt32BE(o.mtimeNanoseconds),a.writeUInt32BE(o.dev),a.writeUInt32BE(o.ino),a.writeUInt32BE(o.mode),a.writeUInt32BE(o.uid),a.writeUInt32BE(o.gid),a.writeUInt32BE(o.size),a.write(e.oid,20,"hex"),a.writeUInt16BE(Rl(e)),a.write(e.path,r.length,"utf8"),i}async toObject(){const e=Buffer.alloc(12),r=new Gt(e);r.write("DIRC",4,"utf8"),r.writeUInt32BE(2),r.writeUInt32BE(this.entriesFlat.length);let n=[];for(const s of this.entries)if(n.push(ve._entryToBuffer(s)),s.stages.length>1)for(const h of s.stages)h&&h!==s&&n.push(ve._entryToBuffer(h));n=await Promise.all(n);const i=Buffer.concat(n),a=Buffer.concat([e,i]),o=await Jt(a);return Buffer.concat([a,Buffer.from(o,"hex")])}}function ln(t,e){const r=Ze(t),n=Ze(e);return r.mode!==n.mode||r.mtimeSeconds!==n.mtimeSeconds||r.ctimeSeconds!==n.ctimeSeconds||r.uid!==n.uid||r.gid!==n.gid||r.ino!==n.ino||r.size!==n.size}let Kn=null;const Pe=Symbol("IndexCache");function Ol(){return{map:new Map,stats:new Map}}async function Cl(t,e,r){const n=await t.lstat(e),i=await t.read(e),a=await ve.from(i);r.map.set(e,a),r.stats.set(e,n)}async function Fl(t,e,r){const n=r.stats.get(e);if(n===void 0)return!0;const i=await t.lstat(e);return n===null||i===null?!1:ln(n,i)}class dt{static async acquire({fs:e,gitdir:r,cache:n,allowUnmerged:i=!0},a){n[Pe]||(n[Pe]=Ol());const o=`${r}/index`;Kn===null&&(Kn=new ni({maxPending:1/0}));let s,h=[];return await Kn.acquire(o,async()=>{await Fl(e,o,n[Pe])&&await Cl(e,o,n[Pe]);const l=n[Pe].map.get(o);if(h=l.unmergedPaths,h.length&&!i)throw new Ir(h);if(s=await a(l),l._dirty){const f=await l.toObject();await e.write(o,f),n[Pe].stats.set(o,await e.lstat(o)),l._dirty=!1}}),s}}function un(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return e>-1&&(t=t.slice(e+1)),t}function Ge(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return e===-1?".":e===0?"/":t.slice(0,e)}function rs(t){const e=new Map,r=function(i){if(!e.has(i)){const a={type:"tree",fullpath:i,basename:un(i),metadata:{},children:[]};e.set(i,a),a.parent=r(Ge(i)),a.parent&&a.parent!==a&&a.parent.children.push(a)}return e.get(i)},n=function(i,a){if(!e.has(i)){const o={type:"blob",fullpath:i,basename:un(i),metadata:a,parent:r(Ge(i)),children:[]};o.parent&&o.parent.children.push(o),e.set(i,o)}return e.get(i)};r(".");for(const i of t)n(i.path,i);return e}function Nl(t){switch(t){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new j(`Unexpected GitTree entry mode: ${t.toString(8)}`)}class Ul{constructor({fs:e,gitdir:r,cache:n}){this.treePromise=dt.acquire({fs:e,gitdir:r,cache:n},async function(a){return rs(a.entries)});const i=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(e){const r=e._fullpath,i=(await this.treePromise).get(r);if(!i||i.type==="blob")return null;if(i.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${r}'`);const a=i.children.map(o=>o.fullpath);return a.sort(En),a}async type(e){return e._type===!1&&await e.stat(),e._type}async mode(e){return e._mode===!1&&await e.stat(),e._mode}async stat(e){if(e._stat===!1){const n=(await this.treePromise).get(e._fullpath);if(!n)throw new Error(`ENOENT: no such file or directory, lstat '${e._fullpath}'`);const i=n.type==="tree"?{}:Ze(n.metadata);e._type=n.type==="tree"?"tree":Nl(i.mode),e._mode=i.mode,n.type==="tree"?e._stat=void 0:e._stat=i}return e._stat}async content(e){}async oid(e){if(e._oid===!1){const n=(await this.treePromise).get(e._fullpath);e._oid=n.metadata.oid}return e._oid}}const kn=Symbol("GitWalkSymbol");function Sn(){const t=Object.create(null);return Object.defineProperty(t,kn,{value:function({fs:e,gitdir:r,cache:n}){return new Ul({fs:e,gitdir:r,cache:n})}}),Object.freeze(t),t}class V extends W{constructor(e){super(`Could not find ${e}.`),this.code=this.name=V.code,this.data={what:e}}}V.code="NotFoundError";class yt extends W{constructor(e,r,n,i){super(`Object ${e} ${i?`at ${i}`:""}was anticipated to be a ${n} but it is a ${r}.`),this.code=this.name=yt.code,this.data={oid:e,actual:r,expected:n,filepath:i}}}yt.code="ObjectTypeError";class me extends W{constructor(e){super(`Expected a 40-char hex object id but saw "${e}".`),this.code=this.name=me.code,this.data={value:e}}}me.code="InvalidOidError";class Ar extends W{constructor(e){super(`Could not find a fetch refspec for remote "${e}". Make sure the config file has an entry like the following:
[remote "${e}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=Ar.code,this.data={remote:e}}}Ar.code="NoRefspecError";class hn{constructor(e){if(this.refs=new Map,this.parsedConfig=[],e){let r=null;this.parsedConfig=e.trim().split(`
`).map(n=>{if(/^\s*#/.test(n))return{line:n,comment:!0};const i=n.indexOf(" ");if(n.startsWith("^")){const a=n.slice(1);return this.refs.set(r+"^{}",a),{line:n,ref:r,peeled:a}}else{const a=n.slice(0,i);return r=n.slice(i+1),this.refs.set(r,a),{line:n,ref:r,oid:a}}})}return this}static from(e){return new hn(e)}delete(e){this.parsedConfig=this.parsedConfig.filter(r=>r.ref!==e),this.refs.delete(e)}toString(){return this.parsedConfig.map(({line:e})=>e).join(`
`)+`
`}}class dn{constructor({remotePath:e,localPath:r,force:n,matchPrefix:i}){Object.assign(this,{remotePath:e,localPath:r,force:n,matchPrefix:i})}static from(e){const[r,n,i,a,o]=e.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),s=r==="+",h=i==="*";if(h!==(o==="*"))throw new j("Invalid refspec");return new dn({remotePath:n,localPath:a,force:s,matchPrefix:h})}translate(e){if(this.matchPrefix){if(e.startsWith(this.remotePath))return this.localPath+e.replace(this.remotePath,"")}else if(e===this.remotePath)return this.localPath;return null}reverseTranslate(e){if(this.matchPrefix){if(e.startsWith(this.localPath))return this.remotePath+e.replace(this.localPath,"")}else if(e===this.localPath)return this.remotePath;return null}}class Ri{constructor(e=[]){this.rules=e}static from(e){const r=[];for(const n of e)r.push(dn.from(n));return new Ri(r)}add(e){const r=dn.from(e);this.rules.push(r)}translate(e){const r=[];for(const n of this.rules)for(const i of e){const a=n.translate(i);a&&r.push([i,a])}return r}translateOne(e){let r=null;for(const n of this.rules){const i=n.translate(e);i&&(r=i)}return r}localNamespaces(){return this.rules.filter(e=>e.matchPrefix).map(e=>e.localPath.replace(/\/$/,""))}}function Dl(t,e){const r=t.replace(/\^\{\}$/,""),n=e.replace(/\^\{\}$/,""),i=-(r<n)||+(r>n);return i===0?t.endsWith("^{}")?1:-1:i}function Fa(t){return t.replace(/\/\.\//g,"/").replace(/\/{2,}/g,"/").replace(/^\/\.$/,"/").replace(/^\.\/$/,".").replace(/^\.\//,"").replace(/\/\.$/,"").replace(/(.+)\/$/,"$1").replace(/^$/,".")}function F(...t){return Fa(t.map(Fa).join("/"))}const Pl=t=>{t=t.toLowerCase();let e=parseInt(t);return t.endsWith("k")&&(e*=1024),t.endsWith("m")&&(e*=1024*1024),t.endsWith("g")&&(e*=1024*1024*1024),e},lr=t=>{if(t=t.trim().toLowerCase(),t==="true"||t==="yes"||t==="on")return!0;if(t==="false"||t==="no"||t==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${t}`)},Na={core:{filemode:lr,bare:lr,logallrefupdates:lr,symlinks:lr,ignorecase:lr,bigFileThreshold:Pl}},zl=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,Ml=/^[A-Za-z0-9-.]+$/,jl=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Ll=/^[A-Za-z][A-Za-z-]*$/,Hl=/^(.*?)( *[#;].*)$/,Zl=t=>{const e=zl.exec(t);if(e!=null){const[r,n]=e.slice(1);return[r,n]}return null},Gl=t=>{const e=jl.exec(t);if(e!=null){const[r,n="true"]=e.slice(1),i=Wl(n),a=ql(i);return[r,a]}return null},Wl=t=>{const e=Hl.exec(t);if(e==null)return t;const[r,n]=e.slice(1);return Ua(r)&&Ua(n)?`${r}${n}`:r},Ua=t=>(t.match(/(?:^|[^\\])"/g)||[]).length%2!==0,ql=t=>t.split("").reduce((e,r,n,i)=>{const a=r==='"'&&i[n-1]!=="\\",o=r==="\\"&&i[n+1]==='"';return a||o?e:e+r},""),Da=t=>t!=null?t.toLowerCase():null,wi=(t,e,r)=>[Da(t),e,Da(r)].filter(n=>n!=null).join("."),Pa=t=>{const e=t.split("."),r=e.shift(),n=e.pop(),i=e.length?e.join("."):void 0;return{section:r,subsection:i,name:n,path:wi(r,i,n),sectionPath:wi(r,i,null)}},Xl=(t,e)=>t.reduce((r,n,i)=>e(n)?i:r,-1);class Oi{constructor(e){let r=null,n=null;this.parsedConfig=e.split(`
`).map(i=>{let a=null,o=null;const s=i.trim(),h=Zl(s),l=h!=null;if(l)[r,n]=h;else{const d=Gl(s);d!=null&&([a,o]=d)}const f=wi(r,n,a);return{line:i,isSection:l,section:r,subsection:n,name:a,value:o,path:f}})}static from(e){return new Oi(e)}async get(e,r=!1){const n=Pa(e).path,i=this.parsedConfig.filter(a=>a.path===n).map(({section:a,name:o,value:s})=>{const h=Na[a]&&Na[a][o];return h?h(s):s});return r?i:i.pop()}async getall(e){return this.get(e,!0)}async getSubsections(e){return this.parsedConfig.filter(r=>r.section===e&&r.isSection).map(r=>r.subsection)}async deleteSection(e,r){this.parsedConfig=this.parsedConfig.filter(n=>!(n.section===e&&n.subsection===r))}async append(e,r){return this.set(e,r,!0)}async set(e,r,n=!1){const{section:i,subsection:a,name:o,path:s,sectionPath:h}=Pa(e),l=Xl(this.parsedConfig,f=>f.path===s);if(r==null)l!==-1&&this.parsedConfig.splice(l,1);else if(l!==-1){const f=this.parsedConfig[l],d=Object.assign({},f,{name:o,value:r,modified:!0});n?this.parsedConfig.splice(l+1,0,d):this.parsedConfig[l]=d}else{const f=this.parsedConfig.findIndex(p=>p.path===h),d={section:i,subsection:a,name:o,value:r,modified:!0,path:s};if(Ml.test(i)&&Ll.test(o))if(f>=0)this.parsedConfig.splice(f+1,0,d);else{const p={section:i,subsection:a,modified:!0,path:h};this.parsedConfig.push(p,d)}}}toString(){return this.parsedConfig.map(({line:e,section:r,subsection:n,name:i,value:a,modified:o=!1})=>o?i!=null&&a!=null?typeof a=="string"&&/[#;]/.test(a)?`	${i} = "${a}"`:`	${i} = ${a}`:n!=null?`[${r} "${n}"]`:`[${r}]`:e).join(`
`)}}class pt{static async get({fs:e,gitdir:r}){const n=await e.read(`${r}/config`,{encoding:"utf8"});return Oi.from(n)}static async save({fs:e,gitdir:r,config:n}){await e.write(`${r}/config`,n.toString(),{encoding:"utf8"})}}const Qr=t=>[`${t}`,`refs/${t}`,`refs/tags/${t}`,`refs/heads/${t}`,`refs/remotes/${t}`,`refs/remotes/${t}/HEAD`],Yl=["config","description","index","shallow","commondir"];class D{static async updateRemoteRefs({fs:e,gitdir:r,remote:n,refs:i,symrefs:a,tags:o,refspecs:s=void 0,prune:h=!1,pruneTags:l=!1}){for(const E of i.values())if(!E.match(/[0-9a-f]{40}/))throw new me(E);const f=await pt.get({fs:e,gitdir:r});if(!s){if(s=await f.getall(`remote.${n}.fetch`),s.length===0)throw new Ar(n);s.unshift(`+HEAD:refs/remotes/${n}/HEAD`)}const d=Ri.from(s),p=new Map;if(l){const E=await D.listRefs({fs:e,gitdir:r,filepath:"refs/tags"});await D.deleteRefs({fs:e,gitdir:r,refs:E.map(x=>`refs/tags/${x}`)})}if(o){for(const E of i.keys())if(E.startsWith("refs/tags")&&!E.endsWith("^{}")&&!await D.exists({fs:e,gitdir:r,ref:E})){const x=i.get(E);p.set(E,x)}}const m=d.translate([...i.keys()]);for(const[E,x]of m){const $=i.get(E);p.set(x,$)}const g=d.translate([...a.keys()]);for(const[E,x]of g){const $=a.get(E),A=d.translateOne($);A&&p.set(x,`ref: ${A}`)}const b=[];if(h){for(const E of d.localNamespaces()){const x=(await D.listRefs({fs:e,gitdir:r,filepath:E})).map($=>`${E}/${$}`);for(const $ of x)p.has($)||b.push($)}b.length>0&&await D.deleteRefs({fs:e,gitdir:r,refs:b})}for(const[E,x]of p)await e.write(F(r,E),`${x.trim()}
`,"utf8");return{pruned:b}}static async writeRef({fs:e,gitdir:r,ref:n,value:i}){if(!i.match(/[0-9a-f]{40}/))throw new me(i);await e.write(F(r,n),`${i.trim()}
`,"utf8")}static async writeSymbolicRef({fs:e,gitdir:r,ref:n,value:i}){await e.write(F(r,n),`ref: ${i.trim()}
`,"utf8")}static async deleteRef({fs:e,gitdir:r,ref:n}){return D.deleteRefs({fs:e,gitdir:r,refs:[n]})}static async deleteRefs({fs:e,gitdir:r,refs:n}){await Promise.all(n.map(s=>e.rm(F(r,s))));let i=await e.read(`${r}/packed-refs`,{encoding:"utf8"});const a=hn.from(i),o=a.refs.size;for(const s of n)a.refs.has(s)&&a.delete(s);a.refs.size<o&&(i=a.toString(),await e.write(`${r}/packed-refs`,i,{encoding:"utf8"}))}static async resolve({fs:e,gitdir:r,ref:n,depth:i=void 0}){if(i!==void 0&&(i--,i===-1))return n;let a;if(n.startsWith("ref: "))return n=n.slice(5),D.resolve({fs:e,gitdir:r,ref:n,depth:i});if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const o=await D.packedRefs({fs:e,gitdir:r}),s=Qr(n).filter(h=>!Yl.includes(h));for(const h of s)if(a=await e.read(`${r}/${h}`,{encoding:"utf8"})||o.get(h),a)return D.resolve({fs:e,gitdir:r,ref:a.trim(),depth:i});throw new V(n)}static async exists({fs:e,gitdir:r,ref:n}){try{return await D.expand({fs:e,gitdir:r,ref:n}),!0}catch{return!1}}static async expand({fs:e,gitdir:r,ref:n}){if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const i=await D.packedRefs({fs:e,gitdir:r}),a=Qr(n);for(const o of a)if(await e.exists(`${r}/${o}`)||i.has(o))return o;throw new V(n)}static async expandAgainstMap({ref:e,map:r}){const n=Qr(e);for(const i of n)if(await r.has(i))return i;throw new V(e)}static resolveAgainstMap({ref:e,fullref:r=e,depth:n=void 0,map:i}){if(n!==void 0&&(n--,n===-1))return{fullref:r,oid:e};if(e.startsWith("ref: "))return e=e.slice(5),D.resolveAgainstMap({ref:e,fullref:r,depth:n,map:i});if(e.length===40&&/[0-9a-f]{40}/.test(e))return{fullref:r,oid:e};const a=Qr(e);for(const o of a){const s=i.get(o);if(s)return D.resolveAgainstMap({ref:s.trim(),fullref:o,depth:n,map:i})}throw new V(e)}static async packedRefs({fs:e,gitdir:r}){const n=await e.read(`${r}/packed-refs`,{encoding:"utf8"});return hn.from(n).refs}static async listRefs({fs:e,gitdir:r,filepath:n}){const i=D.packedRefs({fs:e,gitdir:r});let a=null;try{a=await e.readdirDeep(`${r}/${n}`),a=a.map(o=>o.replace(`${r}/${n}/`,""))}catch{a=[]}for(let o of(await i).keys())o.startsWith(n)&&(o=o.replace(n+"/",""),a.includes(o)||a.push(o));return a.sort(Dl),a}static async listBranches({fs:e,gitdir:r,remote:n}){return n?D.listRefs({fs:e,gitdir:r,filepath:`refs/remotes/${n}`}):D.listRefs({fs:e,gitdir:r,filepath:"refs/heads"})}static async listTags({fs:e,gitdir:r}){return(await D.listRefs({fs:e,gitdir:r,filepath:"refs/tags"})).filter(i=>!i.endsWith("^{}"))}}function Kl(t,e){return En(za(t),za(e))}function za(t){return t.mode==="040000"?t.path+"/":t.path}function ns(t){switch(t){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new j(`Unexpected GitTree entry mode: ${t}`)}function Vl(t){const e=[];let r=0;for(;r<t.length;){const n=t.indexOf(32,r);if(n===-1)throw new j(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);const i=t.indexOf(0,r);if(i===-1)throw new j(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let a=t.slice(r,n).toString("utf8");a==="40000"&&(a="040000");const o=ns(a),s=t.slice(n+1,i).toString("utf8");if(s.includes("\\")||s.includes("/"))throw new tr(s);const h=t.slice(i+1,i+21).toString("hex");r=i+21,e.push({mode:a,path:s,oid:h,type:o})}return e}function Ql(t){if(typeof t=="number"&&(t=t.toString(8)),t.match(/^0?4.*/))return"040000";if(t.match(/^1006.*/))return"100644";if(t.match(/^1007.*/))return"100755";if(t.match(/^120.*/))return"120000";if(t.match(/^160.*/))return"160000";throw new j(`Could not understand file mode: ${t}`)}function Jl(t){return!t.oid&&t.sha&&(t.oid=t.sha),t.mode=Ql(t.mode),t.type||(t.type=ns(t.mode)),t}class vt{constructor(e){if(Buffer.isBuffer(e))this._entries=Vl(e);else if(Array.isArray(e))this._entries=e.map(Jl);else throw new j("invalid type passed to GitTree constructor");this._entries.sort(Jo)}static from(e){return new vt(e)}render(){return this._entries.map(e=>`${e.mode} ${e.type} ${e.oid}    ${e.path}`).join(`
`)}toObject(){const e=[...this._entries];return e.sort(Kl),Buffer.concat(e.map(r=>{const n=Buffer.from(r.mode.replace(/^0/,"")),i=Buffer.from(" "),a=Buffer.from(r.path,"utf8"),o=Buffer.from([0]),s=Buffer.from(r.oid,"hex");return Buffer.concat([n,i,a,o,s])}))}entries(){return this._entries}*[Symbol.iterator](){for(const e of this._entries)yield e}}class er{static wrap({type:e,object:r}){return Buffer.concat([Buffer.from(`${e} ${r.byteLength.toString()}\0`),Buffer.from(r)])}static unwrap(e){const r=e.indexOf(32),n=e.indexOf(0),i=e.slice(0,r).toString("utf8"),a=e.slice(r+1,n).toString("utf8"),o=e.length-(n+1);if(parseInt(a)!==o)throw new j(`Length mismatch: expected ${a} bytes but got ${o} instead.`);return{type:i,object:Buffer.from(e.slice(n+1))}}}async function tu({fs:t,gitdir:e,oid:r}){const n=`objects/${r.slice(0,2)}/${r.slice(2)}`,i=await t.read(`${e}/${n}`);return i?{object:i,format:"deflated",source:n}:null}function eu(t,e){const r=new Gt(t),n=Ma(r);if(n!==e.byteLength)throw new j(`applyDelta expected source buffer to be ${n} bytes but the provided buffer was ${e.length} bytes`);const i=Ma(r);let a;const o=La(r,e);if(o.byteLength===i)a=o;else{a=Buffer.alloc(i);const s=new Gt(a);for(s.copy(o);!r.eof();)s.copy(La(r,e));const h=s.tell();if(i!==h)throw new j(`applyDelta expected target buffer to be ${i} bytes but the resulting buffer was ${h} bytes`)}return a}function Ma(t){let e=0,r=0,n=null;do n=t.readUInt8(),e|=(n&127)<<r,r+=7;while(n&128);return e}function ja(t,e,r){let n=0,i=0;for(;r--;)e&1&&(n|=t.readUInt8()<<i),e>>=1,i+=8;return n}function La(t,e){const r=t.readUInt8(),n=128,i=15,a=112;if(r&n){const o=ja(t,r&i,4);let s=ja(t,(r&a)>>4,3);return s===0&&(s=65536),e.slice(o,o+s)}else return t.slice(r)}function ru(t){let e=[t];return{next(){return Promise.resolve({done:e.length===0,value:e.pop()})},return(){return e=[],{}},[Symbol.asyncIterator](){return this}}}function is(t){return t[Symbol.asyncIterator]?t[Symbol.asyncIterator]():t[Symbol.iterator]?t[Symbol.iterator]():t.next?t:ru(t)}class as{constructor(e){this.stream=is(e),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(e){if(!this.eof())return this.started||await this._init(),this.cursor+e>this.buffer.length&&(this._trim(),await this._accumulate(e)),this._moveCursor(e),this.buffer.slice(this.undoCursor,this.cursor)}async skip(e){this.eof()||(this.started||await this._init(),this.cursor+e>this.buffer.length&&(this._trim(),await this._accumulate(e)),this._moveCursor(e))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:e,value:r}=await this.stream.next();return e&&(this._ended=!0),r&&(r=Buffer.from(r)),r}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(e){this.undoCursor=this.cursor,this.cursor+=e,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(e){if(this._ended)return;const r=[this.buffer];for(;this.cursor+e>nu(r);){const n=await this._next();if(this._ended)break;r.push(n)}this.buffer=Buffer.concat(r)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function nu(t){return t.reduce((e,r)=>e+r.length,0)}async function iu(t,e){const r=new as(t);let n=await r.read(4);if(n=n.toString("utf8"),n!=="PACK")throw new j(`Invalid PACK header '${n}'`);let i=await r.read(4);if(i=i.readUInt32BE(0),i!==2)throw new j(`Invalid packfile version: ${i}`);let a=await r.read(4);if(a=a.readUInt32BE(0),!(a<1))for(;!r.eof()&&a--;){const o=r.tell(),{type:s,length:h,ofs:l,reference:f}=await au(r),d=new Ai.Inflate;for(;!d.result;){const p=await r.chunk();if(!p)break;if(d.push(p,!1),d.err)throw new j(`Pako error: ${d.msg}`);if(d.result){if(d.result.length!==h)throw new j("Inflated object size is different from that stated in packfile.");await r.undo(),await r.read(p.length-d.strm.avail_in);const m=r.tell();await e({data:d.result,type:s,num:a,offset:o,end:m,reference:f,ofs:l})}}}}async function au(t){let e=await t.byte();const r=e>>4&7;let n=e&15;if(e&128){let o=4;do e=await t.byte(),n|=(e&127)<<o,o+=7;while(e&128)}let i,a;if(r===6){let o=0;i=0;const s=[];do e=await t.byte(),i|=(e&127)<<o,o+=7,s.push(e);while(e&128);a=Buffer.from(s)}return r===7&&(a=await t.read(20)),{type:r,length:n,ofs:i,reference:a}}async function os(t){return Ai.inflate(t)}function ou(t){const e=[];let r=0,n=0;do{r=t.readUInt8();const i=r&127;e.push(i),n=r&128}while(n);return e.reduce((i,a)=>i+1<<7|a,-1)}function su(t,e){let r=e,n=4,i=null;do i=t.readUInt8(),r|=(i&127)<<n,n+=7;while(i&128);return r}class We{constructor(e){Object.assign(this,e),this.offsetCache={}}static async fromIdx({idx:e,getExternalRefDelta:r}){const n=new Gt(e);if(n.slice(4).toString("hex")!=="ff744f63")return;const a=n.readUInt32BE();if(a!==2)throw new j(`Unable to read version ${a} packfile IDX. (Only version 2 supported)`);if(e.byteLength>2048*1024*1024)throw new j("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");n.seek(n.tell()+4*255);const o=n.readUInt32BE(),s=[];for(let f=0;f<o;f++){const d=n.slice(20).toString("hex");s[f]=d}n.seek(n.tell()+4*o);const h=new Map;for(let f=0;f<o;f++)h.set(s[f],n.readUInt32BE());const l=n.slice(20).toString("hex");return new We({hashes:s,crcs:{},offsets:h,packfileSha:l,getExternalRefDelta:r})}static async fromPack({pack:e,getExternalRefDelta:r,onProgress:n}){const i={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},a={},o=e.slice(-20).toString("hex"),s=[],h={},l=new Map;let f=null,d=null;await iu([e],async({data:E,type:x,reference:$,offset:A,num:B})=>{f===null&&(f=B);const S=Math.floor((f-B)*100/f);S!==d&&n&&await n({phase:"Receiving objects",loaded:f-B,total:f}),d=S,x=i[x],["commit","tree","blob","tag"].includes(x)?a[A]={type:x,offset:A}:x==="ofs-delta"?a[A]={type:x,offset:A}:x==="ref-delta"&&(a[A]={type:x,offset:A})});const p=Object.keys(a).map(Number);for(const[E,x]of p.entries()){const $=E+1===p.length?e.byteLength-20:p[E+1],A=a[x],B=ec.buf(e.slice(x,$))>>>0;A.end=$,A.crc=B}const m=new We({pack:Promise.resolve(e),packfileSha:o,crcs:h,hashes:s,offsets:l,getExternalRefDelta:r});d=null;let g=0;const b=[0,0,0,0,0,0,0,0,0,0,0,0];for(let E in a){E=Number(E);const x=Math.floor(g*100/f);x!==d&&n&&await n({phase:"Resolving deltas",loaded:g,total:f}),g++,d=x;const $=a[E];if(!$.oid)try{m.readDepth=0,m.externalReadDepth=0;const{type:A,object:B}=await m.readSlice({start:E});b[m.readDepth]+=1;const S=await Jt(er.wrap({type:A,object:B}));$.oid=S,s.push(S),l.set(S,E),h[S]=$.crc}catch{continue}}return s.sort(),m}async toBuffer(){const e=[],r=(l,f)=>{e.push(Buffer.from(l,f))};r("ff744f63","hex"),r("00000002","hex");const n=new Gt(Buffer.alloc(256*4));for(let l=0;l<256;l++){let f=0;for(const d of this.hashes)parseInt(d.slice(0,2),16)<=l&&f++;n.writeUInt32BE(f)}e.push(n.buffer);for(const l of this.hashes)r(l,"hex");const i=new Gt(Buffer.alloc(this.hashes.length*4));for(const l of this.hashes)i.writeUInt32BE(this.crcs[l]);e.push(i.buffer);const a=new Gt(Buffer.alloc(this.hashes.length*4));for(const l of this.hashes)a.writeUInt32BE(this.offsets.get(l));e.push(a.buffer),r(this.packfileSha,"hex");const o=Buffer.concat(e),s=await Jt(o),h=Buffer.alloc(20);return h.write(s,"hex"),Buffer.concat([o,h])}async load({pack:e}){this.pack=e}async unload(){this.pack=null}async read({oid:e}){if(!this.offsets.get(e)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(e);throw new j(`Could not read object ${e} from packfile`)}const r=this.offsets.get(e);return this.readSlice({start:r})}async readSlice({start:e}){if(this.offsetCache[e])return Object.assign({},this.offsetCache[e]);this.readDepth++;const r={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new j("Tried to read from a GitPackIndex with no packfile loaded into memory");const n=(await this.pack).slice(e),i=new Gt(n),a=i.readUInt8(),o=a&112;let s=r[o];if(s===void 0)throw new j("Unrecognized type: 0b"+o.toString(2));const h=a&15;let l=h;a&128&&(l=su(i,h));let d=null,p=null;if(s==="ofs_delta"){const g=ou(i),b=e-g;({object:d,type:s}=await this.readSlice({start:b}))}if(s==="ref_delta"){const g=i.slice(20).toString("hex");({object:d,type:s}=await this.read({oid:g}))}const m=n.slice(i.tell());if(p=Buffer.from(await os(m)),p.byteLength!==l)throw new j(`Packfile told us object would have length ${l} but it had length ${p.byteLength}`);return d&&(p=Buffer.from(eu(p,d))),this.readDepth>3&&(this.offsetCache[e]={type:s,object:p}),{type:s,format:"content",object:p}}}const Jr=Symbol("PackfileCache");async function cu({fs:t,filename:e,getExternalRefDelta:r,emitter:n,emitterPrefix:i}){const a=await t.read(e);return We.fromIdx({idx:a,getExternalRefDelta:r})}function Ci({fs:t,cache:e,filename:r,getExternalRefDelta:n,emitter:i,emitterPrefix:a}){e[Jr]||(e[Jr]=new Map);let o=e[Jr].get(r);return o||(o=cu({fs:t,filename:r,getExternalRefDelta:n,emitter:i,emitterPrefix:a}),e[Jr].set(r,o)),o}async function fu({fs:t,cache:e,gitdir:r,oid:n,format:i="content",getExternalRefDelta:a}){let o=await t.readdir(F(r,"objects/pack"));o=o.filter(s=>s.endsWith(".idx"));for(const s of o){const h=`${r}/objects/pack/${s}`,l=await Ci({fs:t,cache:e,filename:h,getExternalRefDelta:a});if(l.error)throw new j(l.error);if(l.offsets.has(n)){if(!l.pack){const d=h.replace(/idx$/,"pack");l.pack=t.read(d)}const f=await l.read({oid:n,getExternalRefDelta:a});return f.format="content",f.source=`objects/pack/${s.replace(/idx$/,"pack")}`,f}}return null}async function rt({fs:t,cache:e,gitdir:r,oid:n,format:i="content"}){const a=s=>rt({fs:t,cache:e,gitdir:r,oid:s});let o;if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(o={format:"wrapped",object:Buffer.from("tree 0\0")}),o||(o=await tu({fs:t,gitdir:r,oid:n})),o||(o=await fu({fs:t,cache:e,gitdir:r,oid:n,getExternalRefDelta:a})),!o)throw new V(n);if(i==="deflated")return o;if(o.format==="deflated"&&(o.object=Buffer.from(await os(o.object)),o.format="wrapped"),o.format==="wrapped"){if(i==="wrapped"&&o.format==="wrapped")return o;const s=await Jt(o.object);if(s!==n)throw new j(`SHA check failed! Expected ${n}, computed ${s}`);const{object:h,type:l}=er.unwrap(o.object);o.type=l,o.object=h,o.format="content"}if(o.format==="content")return i==="content"?o:void 0;throw new j(`invalid format "${o.format}"`)}class Nt extends W{constructor(e,r,n=!0){super(`Failed to create ${e} at ${r} because it already exists.${n?` (Hint: use 'force: true' parameter to overwrite existing ${e}.)`:""}`),this.code=this.name=Nt.code,this.data={noun:e,where:r,canForce:n}}}Nt.code="AlreadyExistsError";class Tr extends W{constructor(e,r,n){super(`Found multiple ${e} matching "${r}" (${n.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=Tr.code,this.data={nouns:e,short:r,matches:n}}}Tr.code="AmbiguousError";class Rr extends W{constructor(e){super(`Your local changes to the following files would be overwritten by checkout: ${e.join(", ")}`),this.code=this.name=Rr.code,this.data={filepaths:e}}}Rr.code="CheckoutConflictError";class Or extends W{constructor(e,r){super(`Failed to checkout "${e}" because commit ${r} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=Or.code,this.data={ref:e,oid:r}}}Or.code="CommitNotFetchedError";class Cr extends W{constructor(){super("Empty response from git server."),this.code=this.name=Cr.code,this.data={}}}Cr.code="EmptyServerResponseError";class Fr extends W{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=Fr.code,this.data={}}}Fr.code="FastForwardError";class Nr extends W{constructor(e,r){super(`One or more branches were not updated: ${e}`),this.code=this.name=Nr.code,this.data={prettyDetails:e,result:r}}}Nr.code="GitPushError";class qe extends W{constructor(e,r,n){super(`HTTP Error: ${e} ${r}`),this.code=this.name=qe.code,this.data={statusCode:e,statusMessage:r,response:n}}}qe.code="HttpError";class _e extends W{constructor(e){let r="invalid filepath";e==="leading-slash"||e==="trailing-slash"?r='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':e==="directory"&&(r='"filepath" should not be a directory.'),super(r),this.code=this.name=_e.code,this.data={reason:e}}}_e.code="InvalidFilepathError";class te extends W{constructor(e,r){super(`"${e}" would be an invalid git reference. (Hint: a valid alternative would be "${r}".)`),this.code=this.name=te.code,this.data={ref:e,suggestion:r}}}te.code="InvalidRefNameError";class Ur extends W{constructor(e){super(`Maximum search depth of ${e} exceeded.`),this.code=this.name=Ur.code,this.data={depth:e}}}Ur.code="MaxDepthError";class rr extends W{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=rr.code,this.data={}}}rr.code="MergeNotSupportedError";class nr extends W{constructor(e){super(`Automatic merge failed with one or more merge conflicts in the following files: ${e.toString()}. Fix conflicts then commit the result.`),this.code=this.name=nr.code,this.data={filepaths:e}}}nr.code="MergeConflictError";class gt extends W{constructor(e){super(`No name was provided for ${e} in the argument or in the .git/config file.`),this.code=this.name=gt.code,this.data={role:e}}}gt.code="MissingNameError";class kt extends W{constructor(e){super(`The function requires a "${e}" parameter but none was provided.`),this.code=this.name=kt.code,this.data={parameter:e}}}kt.code="MissingParameterError";class Dr extends W{constructor(e){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=Dr.code,this.data={errors:e},this.errors=e}}Dr.code="MultipleGitError";class Re extends W{constructor(e,r){super(`Expected "${e}" but received "${r}".`),this.code=this.name=Re.code,this.data={expected:e,actual:r}}}Re.code="ParseError";class Xe extends W{constructor(e){let r="";e==="not-fast-forward"?r=" because it was not a simple fast-forward":e==="tag-exists"&&(r=" because tag already exists"),super(`Push rejected${r}. Use "force: true" to override.`),this.code=this.name=Xe.code,this.data={reason:e}}}Xe.code="PushRejectedError";class de extends W{constructor(e,r){super(`Remote does not support the "${e}" so the "${r}" parameter cannot be used.`),this.code=this.name=de.code,this.data={capability:e,parameter:r}}}de.code="RemoteCapabilityError";class Pr extends W{constructor(e,r){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${e}`),this.code=this.name=Pr.code,this.data={preview:e,response:r}}}Pr.code="SmartHttpError";class zr extends W{constructor(e,r,n){super(`Git remote "${e}" uses an unrecognized transport protocol: "${r}"`),this.code=this.name=zr.code,this.data={url:e,transport:r,suggestion:n}}}zr.code="UnknownTransportError";class Mr extends W{constructor(e){super(`Cannot parse remote URL: "${e}"`),this.code=this.name=Mr.code,this.data={url:e}}}Mr.code="UrlParseError";class jr extends W{constructor(){super("The operation was canceled."),this.code=this.name=jr.code,this.data={}}}jr.code="UserCanceledError";class Lr extends W{constructor(e){super(`Could not merge index: Entry for '${e}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged chages.`),this.code=this.name=Lr.code,this.data={filepath:e}}}Lr.code="IndexResetError";var lu=Object.freeze({__proto__:null,AlreadyExistsError:Nt,AmbiguousError:Tr,CheckoutConflictError:Rr,CommitNotFetchedError:Or,EmptyServerResponseError:Cr,FastForwardError:Fr,GitPushError:Nr,HttpError:qe,InternalError:j,InvalidFilepathError:_e,InvalidOidError:me,InvalidRefNameError:te,MaxDepthError:Ur,MergeNotSupportedError:rr,MergeConflictError:nr,MissingNameError:gt,MissingParameterError:kt,MultipleGitError:Dr,NoRefspecError:Ar,NotFoundError:V,ObjectTypeError:yt,ParseError:Re,PushRejectedError:Xe,RemoteCapabilityError:de,SmartHttpError:Pr,UnknownTransportError:zr,UnsafeFilepathError:tr,UrlParseError:Mr,UserCanceledError:jr,UnmergedPathsError:Ir,IndexResetError:Lr});function pi({name:t,email:e,timestamp:r,timezoneOffset:n}){return n=uu(n),`${t} <${e}> ${r} ${n}`}function uu(t){const e=hu(du(t));t=Math.abs(t);const r=Math.floor(t/60);t-=r*60;let n=String(r),i=String(t);return n.length<2&&(n="0"+n),i.length<2&&(i="0"+i),(e===-1?"-":"+")+n+i}function hu(t){return Math.sign(t)||(Object.is(t,-0)?-1:1)}function du(t){return t===0?t:-t}function Vt(t){return t=t.replace(/\r/g,""),t=t.replace(/^\n+/,""),t=t.replace(/\n+$/,"")+`
`,t}function wn(t){const[,e,r,n,i]=t.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:e,email:r,timestamp:Number(n),timezoneOffset:wu(i)}}function wu(t){let[,e,r,n]=t.match(/(\+|-)(\d\d)(\d\d)/);return n=(e==="+"?1:-1)*(Number(r)*60+Number(n)),pu(n)}function pu(t){return t===0?t:-t}class _t{constructor(e){if(typeof e=="string")this._tag=e;else if(Buffer.isBuffer(e))this._tag=e.toString("utf8");else if(typeof e=="object")this._tag=_t.render(e);else throw new j("invalid type passed to GitAnnotatedTag constructor")}static from(e){return new _t(e)}static render(e){return`object ${e.object}
type ${e.type}
tag ${e.tag}
tagger ${pi(e.tagger)}

${e.message}
${e.gpgsig?e.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const e=this.withoutSignature();return e.slice(e.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const e=this.justHeaders().split(`
`),r=[];for(const i of e)i[0]===" "?r[r.length-1]+=`
`+i.slice(1):r.push(i);const n={};for(const i of r){const a=i.slice(0,i.indexOf(" ")),o=i.slice(i.indexOf(" ")+1);Array.isArray(n[a])?n[a].push(o):n[a]=o}return n.tagger&&(n.tagger=wn(n.tagger)),n.committer&&(n.committer=wn(n.committer)),n}withoutSignature(){const e=Vt(this._tag);return e.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?e:e.slice(0,e.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const e=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return Vt(e)}payload(){return this.withoutSignature()+`
`}toObject(){return Buffer.from(this._tag,"utf8")}static async sign(e,r,n){const i=e.payload();let{signature:a}=await r({payload:i,secretKey:n});a=Vt(a);const o=i+a;return _t.from(o)}}function Vn(t){return t.trim().split(`
`).map(e=>" "+e).join(`
`)+`
`}function mu(t){return t.split(`
`).map(e=>e.replace(/^ /,"")).join(`
`)}class et{constructor(e){if(typeof e=="string")this._commit=e;else if(Buffer.isBuffer(e))this._commit=e.toString("utf8");else if(typeof e=="object")this._commit=et.render(e);else throw new j("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:e,signature:r}){const n=et.justHeaders(e),i=et.justMessage(e),a=Vt(n+`
gpgsig`+Vn(r)+`
`+i);return new et(a)}static from(e){return new et(e)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return et.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(e){return Vt(e.slice(e.indexOf(`

`)+2))}static justHeaders(e){return e.slice(0,e.indexOf(`

`))}parseHeaders(){const e=et.justHeaders(this._commit).split(`
`),r=[];for(const i of e)i[0]===" "?r[r.length-1]+=`
`+i.slice(1):r.push(i);const n={parent:[]};for(const i of r){const a=i.slice(0,i.indexOf(" ")),o=i.slice(i.indexOf(" ")+1);Array.isArray(n[a])?n[a].push(o):n[a]=o}return n.author&&(n.author=wn(n.author)),n.committer&&(n.committer=wn(n.committer)),n}static renderHeaders(e){let r="";if(e.tree?r+=`tree ${e.tree}
`:r+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,e.parent){if(e.parent.length===void 0)throw new j("commit 'parent' property should be an array");for(const a of e.parent)r+=`parent ${a}
`}const n=e.author;r+=`author ${pi(n)}
`;const i=e.committer||e.author;return r+=`committer ${pi(i)}
`,e.gpgsig&&(r+="gpgsig"+Vn(e.gpgsig)),r}static render(e){return et.renderHeaders(e)+`
`+Vt(e.message)}render(){return this._commit}withoutSignature(){const e=Vt(this._commit);if(e.indexOf(`
gpgsig`)===-1)return e;const r=e.slice(0,e.indexOf(`
gpgsig`)),n=e.slice(e.indexOf(`-----END PGP SIGNATURE-----
`)+28);return Vt(r+`
`+n)}isolateSignature(){const e=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return mu(e)}static async sign(e,r,n){const i=e.withoutSignature(),a=et.justMessage(e._commit);let{signature:o}=await r({payload:i,secretKey:n});o=Vt(o);const h=et.justHeaders(e._commit)+`
gpgsig`+Vn(o)+`
`+a;return et.from(h)}}async function Ye({fs:t,cache:e,gitdir:r,oid:n}){if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:vt.from([]),oid:n};const{type:i,object:a}=await rt({fs:t,cache:e,gitdir:r,oid:n});if(i==="tag")return n=_t.from(a).parse().object,Ye({fs:t,cache:e,gitdir:r,oid:n});if(i==="commit")return n=et.from(a).parse().tree,Ye({fs:t,cache:e,gitdir:r,oid:n});if(i!=="tree")throw new yt(n,i,"tree");return{tree:vt.from(a),oid:n}}class _u{constructor({fs:e,gitdir:r,ref:n,cache:i}){this.fs=e,this.cache=i,this.gitdir=r,this.mapPromise=(async()=>{const o=new Map;let s;try{s=await D.resolve({fs:e,gitdir:r,ref:n})}catch(l){l instanceof V&&(s="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const h=await Ye({fs:e,cache:this.cache,gitdir:r,oid:s});return h.type="tree",h.mode="40000",o.set(".",h),o})();const a=this;this.ConstructEntry=class{constructor(s){this._fullpath=s,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(e){const r=e._fullpath,{fs:n,cache:i,gitdir:a}=this,o=await this.mapPromise,s=o.get(r);if(!s)throw new Error(`No obj for ${r}`);const h=s.oid;if(!h)throw new Error(`No oid for obj ${JSON.stringify(s)}`);if(s.type!=="tree")return null;const{type:l,object:f}=await rt({fs:n,cache:i,gitdir:a,oid:h});if(l!==s.type)throw new yt(h,l,s.type);const d=vt.from(f);for(const p of d)o.set(F(r,p.path),p);return d.entries().map(p=>F(r,p.path))}async type(e){if(e._type===!1){const r=await this.mapPromise,{type:n}=r.get(e._fullpath);e._type=n}return e._type}async mode(e){if(e._mode===!1){const r=await this.mapPromise,{mode:n}=r.get(e._fullpath);e._mode=ts(parseInt(n,8))}return e._mode}async stat(e){}async content(e){if(e._content===!1){const r=await this.mapPromise,{fs:n,cache:i,gitdir:a}=this,s=r.get(e._fullpath).oid,{type:h,object:l}=await rt({fs:n,cache:i,gitdir:a,oid:s});h!=="blob"?e._content=void 0:e._content=new Uint8Array(l)}return e._content}async oid(e){if(e._oid===!1){const n=(await this.mapPromise).get(e._fullpath);e._oid=n.oid}return e._oid}}function we({ref:t="HEAD"}={}){const e=Object.create(null);return Object.defineProperty(e,kn,{value:function({fs:r,gitdir:n,cache:i}){return new _u({fs:r,gitdir:n,ref:t,cache:i})}}),Object.freeze(e),e}class gu{constructor({fs:e,dir:r,gitdir:n,cache:i}){this.fs=e,this.cache=i,this.dir=r,this.gitdir=n;const a=this;this.ConstructEntry=class{constructor(s){this._fullpath=s,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(e){const r=e._fullpath,{fs:n,dir:i}=this,a=await n.readdir(F(i,r));return a===null?null:a.map(o=>F(r,o))}async type(e){return e._type===!1&&await e.stat(),e._type}async mode(e){return e._mode===!1&&await e.stat(),e._mode}async stat(e){if(e._stat===!1){const{fs:r,dir:n}=this;let i=await r.lstat(`${n}/${e._fullpath}`);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${e._fullpath}'`);let a=i.isDirectory()?"tree":"blob";a==="blob"&&!i.isFile()&&!i.isSymbolicLink()&&(a="special"),e._type=a,i=Ze(i),e._mode=i.mode,i.size===-1&&e._actualSize&&(i.size=e._actualSize),e._stat=i}return e._stat}async content(e){if(e._content===!1){const{fs:r,dir:n}=this;if(await e.type()==="tree")e._content=void 0;else{const i=await r.read(`${n}/${e._fullpath}`);e._actualSize=i.length,e._stat&&e._stat.size===-1&&(e._stat.size=e._actualSize),e._content=new Uint8Array(i)}}return e._content}async oid(e){if(e._oid===!1){const{fs:r,gitdir:n,cache:i}=this;let a;await dt.acquire({fs:r,gitdir:n,cache:i},async function(o){const s=o.entriesMap.get(e._fullpath),h=await e.stat();!s||ln(h,s)?await e.content()===void 0?a=void 0:(a=await Jt(er.wrap({type:"blob",object:await e.content()})),s&&a===s.oid&&h.mode===s.mode&&ln(h,s)&&o.insert({filepath:e._fullpath,stats:h,oid:a})):a=s.oid}),e._oid=a}return e._oid}}function Bn(){const t=Object.create(null);return Object.defineProperty(t,kn,{value:function({fs:e,dir:r,gitdir:n,cache:i}){return new gu({fs:e,dir:r,gitdir:n,cache:i})}}),Object.freeze(t),t}function yu(t,e){const r=e-t;return Array.from({length:r},(n,i)=>t+i)}const ss=typeof Array.prototype.flat>"u"?t=>t.reduce((e,r)=>e.concat(r),[]):t=>t.flat();class bu{constructor(){this.value=null}consider(e){e!=null&&(this.value===null?this.value=e:e<this.value&&(this.value=e))}reset(){this.value=null}}function*vu(t){const e=new bu;let r;const n=[],i=t.length;for(let a=0;a<i;a++)n[a]=t[a].next().value,n[a]!==void 0&&e.consider(n[a]);if(e.value!==null)for(;;){const a=[];r=e.value,e.reset();for(let o=0;o<i;o++)n[o]!==void 0&&n[o]===r?(a[o]=n[o],n[o]=t[o].next().value):a[o]=null,n[o]!==void 0&&e.consider(n[o]);if(yield a,e.value===null)return}}async function Ke({fs:t,cache:e,dir:r,gitdir:n,trees:i,map:a=async(h,l)=>l,reduce:o=async(h,l)=>{const f=ss(l);return h!==void 0&&f.unshift(h),f},iterate:s=(h,l)=>Promise.all([...l].map(h))}){const h=i.map(m=>m[kn]({fs:t,dir:r,gitdir:n,cache:e})),l=new Array(h.length).fill("."),f=yu(0,h.length),d=async m=>{f.map(E=>{m[E]=m[E]&&new h[E].ConstructEntry(m[E])});const b=(await Promise.all(f.map(E=>m[E]?h[E].readdir(m[E]):[]))).map(E=>E===null?[]:E).map(E=>E[Symbol.iterator]());return{entries:m,children:vu(b)}},p=async m=>{const{entries:g,children:b}=await d(m),E=g.find($=>$&&$._fullpath)._fullpath,x=await a(E,g);if(x!==null){let $=await s(p,b);return $=$.filter(A=>A!==void 0),o(x,$)}};return p(l)}async function mi(t,e){const r=await t.readdir(e);r==null?await t.rm(e):r.length?await Promise.all(r.map(n=>{const i=F(e,n);return t.lstat(i).then(a=>{if(a)return a.isDirectory()?mi(t,i):t.rm(i)})})).then(()=>t.rmdir(e)):await t.rmdir(e)}function xu(t){return Eu(t)&&Ha(t.then)&&Ha(t.catch)}function Eu(t){return t&&typeof t=="object"}function Ha(t){return typeof t=="function"}function Za(t){return xu((r=>{try{return r.readFile().catch(n=>n)}catch(n){return n}})(t))}const Ga=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function Wa(t,e){if(Za(e))for(const r of Ga)t[`_${r}`]=e[r].bind(e);else for(const r of Ga)t[`_${r}`]=Wn(e[r].bind(e));Za(e)?e.rm?t._rm=e.rm.bind(e):e.rmdir.length>1?t._rm=e.rmdir.bind(e):t._rm=mi.bind(null,t):e.rm?t._rm=Wn(e.rm.bind(e)):e.rmdir.length>2?t._rm=Wn(e.rmdir.bind(e)):t._rm=mi.bind(null,t)}class M{constructor(e){if(typeof e._original_unwrapped_fs<"u")return e;const r=Object.getOwnPropertyDescriptor(e,"promises");r&&r.enumerable?Wa(this,e.promises):Wa(this,e),this._original_unwrapped_fs=e}async exists(e,r={}){try{return await this._stat(e),!0}catch(n){if(n.code==="ENOENT"||n.code==="ENOTDIR")return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',n),n}}async read(e,r={}){try{let n=await this._readFile(e,r);return typeof n!="string"&&(n=Buffer.from(n)),n}catch{return null}}async write(e,r,n={}){try{await this._writeFile(e,r,n);return}catch{await this.mkdir(Ge(e)),await this._writeFile(e,r,n)}}async mkdir(e,r=!1){try{await this._mkdir(e);return}catch(n){if(n===null||n.code==="EEXIST")return;if(r)throw n;if(n.code==="ENOENT"){const i=Ge(e);if(i==="."||i==="/"||i===e)throw n;await this.mkdir(i),await this.mkdir(e,!0)}}}async rm(e){try{await this._unlink(e)}catch(r){if(r.code!=="ENOENT")throw r}}async rmdir(e,r){try{r&&r.recursive?await this._rm(e,r):await this._rmdir(e)}catch(n){if(n.code!=="ENOENT")throw n}}async readdir(e){try{const r=await this._readdir(e);return r.sort(En),r}catch(r){return r.code==="ENOTDIR"?null:[]}}async readdirDeep(e){const r=await this._readdir(e);return(await Promise.all(r.map(async i=>{const a=e+"/"+i;return(await this._stat(a)).isDirectory()?this.readdirDeep(a):a}))).reduce((i,a)=>i.concat(a),[])}async lstat(e){try{return await this._lstat(e)}catch(r){if(r.code==="ENOENT")return null;throw r}}async readlink(e,r={encoding:"buffer"}){try{const n=await this._readlink(e,r);return Buffer.isBuffer(n)?n:Buffer.from(n)}catch(n){if(n.code==="ENOENT")return null;throw n}}async writelink(e,r){return this._symlink(r.toString("utf8"),e)}}function v(t,e){if(e===void 0)throw new kt(t)}async function pn(t,e){return!t&&!e?!1:t&&!e||!t&&e?!0:!(await t.type()==="tree"&&await e.type()==="tree"||await t.type()===await e.type()&&await t.mode()===await e.mode()&&await t.oid()===await e.oid())}async function ku({fs:t,dir:e,gitdir:r=F(e,".git"),commit:n="HEAD",cache:i={}}){try{v("fs",t),v("dir",e),v("gitdir",r);const a=new M(t),o=[we({ref:n}),Bn(),Sn()];let s=[];await dt.acquire({fs:a,gitdir:r,cache:i},async function(l){s=l.unmergedPaths});const h=await Ke({fs:a,cache:i,dir:e,gitdir:r,trees:o,map:async function(l,[f,d,p]){const m=!await pn(d,p),g=s.includes(l),b=!await pn(p,f);if(m||g)return f?{path:l,mode:await f.mode(),oid:await f.oid(),type:await f.type(),content:await f.content()}:void 0;if(b)return!1;throw new Lr(l)}});await dt.acquire({fs:a,gitdir:r,cache:i},async function(l){for(const f of h)if(f!==!1){if(!f){await a.rmdir(`${e}/${f.path}`,{recursive:!0}),l.delete({filepath:f.path});continue}if(f.type==="blob"){const d=new TextDecoder().decode(f.content);await a.write(`${e}/${f.path}`,d,{mode:f.mode}),l.insert({filepath:f.path,oid:f.oid,stage:0})}}})}catch(a){throw a.caller="git.abortMerge",a}}class $n{static async isIgnored({fs:e,dir:r,gitdir:n=F(r,".git"),filepath:i}){if(un(i)===".git")return!0;if(i===".")return!1;let a="";const o=F(n,"info","exclude");await e.exists(o)&&(a=await e.read(o,"utf8"));const s=[{gitignore:F(r,".gitignore"),filepath:i}],h=i.split("/").filter(Boolean);for(let f=1;f<h.length;f++){const d=h.slice(0,f).join("/"),p=h.slice(f).join("/");s.push({gitignore:F(r,d,".gitignore"),filepath:p})}let l=!1;for(const f of s){let d;try{d=await e.read(f.gitignore,"utf8")}catch(g){if(g.code==="NOENT")continue}const p=ml().add(a);p.add(d);const m=Ge(f.filepath);if(m!=="."&&p.ignores(m))return!0;l?l=!p.test(f.filepath).unignored:l=p.test(f.filepath).ignored}return l}}async function Su({fs:t,gitdir:e,object:r,format:n,oid:i}){if(n!=="deflated")throw new j("GitObjectStoreLoose expects objects to write to be in deflated format");const a=`objects/${i.slice(0,2)}/${i.slice(2)}`,o=`${e}/${a}`;await t.exists(o)||await t.write(o,r)}let Qn=null;async function cs(t){return Qn===null&&(Qn=$u()),Qn?Bu(t):Ai.deflate(t)}async function Bu(t){const e=new CompressionStream("deflate"),r=new Blob([t]).stream().pipeThrough(e);return new Uint8Array(await new Response(r).arrayBuffer())}function $u(){try{const t=new CompressionStream("deflate");if(new Blob([]).stream(),t)return!0}catch{}return!1}async function St({fs:t,gitdir:e,type:r,object:n,format:i="content",oid:a=void 0,dryRun:o=!1}){return i!=="deflated"&&(i!=="wrapped"&&(n=er.wrap({type:r,object:n})),a=await Jt(n),n=Buffer.from(await cs(n))),o||await Su({fs:t,gitdir:e,object:n,format:"deflated",oid:a}),a}function Iu(t){let e;for(;~(e=t.indexOf(92));)t[e]=47;return t}async function Au({fs:t,dir:e,gitdir:r=F(e,".git"),filepath:n,cache:i={},force:a=!1,parallel:o=!0}){try{v("fs",t),v("dir",e),v("gitdir",r),v("filepath",n);const s=new M(t);await dt.acquire({fs:s,gitdir:r,cache:i},async h=>_i({dir:e,gitdir:r,fs:s,filepath:n,index:h,force:a,parallel:o}))}catch(s){throw s.caller="git.add",s}}async function _i({dir:t,gitdir:e,fs:r,filepath:n,index:i,force:a,parallel:o}){n=Array.isArray(n)?n:[n];const s=n.map(async d=>{if(!a&&await $n.isIgnored({fs:r,dir:t,gitdir:e,filepath:d}))return;const p=await r.lstat(F(t,d));if(!p)throw new V(d);if(p.isDirectory()){const m=await r.readdir(F(t,d));if(o){const g=m.map(b=>_i({dir:t,gitdir:e,fs:r,filepath:[F(d,b)],index:i,force:a,parallel:o}));await Promise.all(g)}else for(const g of m)await _i({dir:t,gitdir:e,fs:r,filepath:[F(d,g)],index:i,force:a,parallel:o})}else{const m=p.isSymbolicLink()?await r.readlink(F(t,d)).then(Iu):await r.read(F(t,d));if(m===null)throw new V(d);const g=await St({fs:r,gitdir:e,type:"blob",object:m});i.insert({filepath:d,stats:p,oid:g})}}),h=await Promise.allSettled(s),l=h.filter(d=>d.status==="rejected").map(d=>d.reason);if(l.length>1)throw new Dr(l);if(l.length===1)throw l[0];return h.filter(d=>d.status==="fulfilled"&&d.value).map(d=>d.value)}async function In({fs:t,cache:e,onSign:r,gitdir:n,message:i,author:a,committer:o,signingKey:s,dryRun:h=!1,noUpdateBranch:l=!1,ref:f,parent:d,tree:p}){return f||(f=await D.resolve({fs:t,gitdir:n,ref:"HEAD",depth:2})),dt.acquire({fs:t,gitdir:n,cache:e,allowUnmerged:!1},async function(m){const b=rs(m.entries).get(".");if(p||(p=await fs({fs:t,gitdir:n,inode:b,dryRun:h})),d)d=await Promise.all(d.map($=>D.resolve({fs:t,gitdir:n,ref:$})));else try{d=[await D.resolve({fs:t,gitdir:n,ref:f})]}catch{d=[]}let E=et.from({tree:p,parent:d,author:a,committer:o,message:i});s&&(E=await et.sign(E,r,s));const x=await St({fs:t,gitdir:n,type:"commit",object:E.toObject(),dryRun:h});return!l&&!h&&await D.writeRef({fs:t,gitdir:n,ref:f,value:x}),x})}async function fs({fs:t,gitdir:e,inode:r,dryRun:n}){const i=r.children;for(const h of i)h.type==="tree"&&(h.metadata.mode="040000",h.metadata.oid=await fs({fs:t,gitdir:e,inode:h,dryRun:n}));const a=i.map(h=>({mode:h.metadata.mode,path:h.basename,oid:h.metadata.oid,type:h.type})),o=vt.from(a);return await St({fs:t,gitdir:e,type:"tree",object:o.toObject(),dryRun:n})}async function Hr({fs:t,cache:e,gitdir:r,oid:n,filepath:i}){if(i.startsWith("/"))throw new _e("leading-slash");if(i.endsWith("/"))throw new _e("trailing-slash");const a=n,o=await Ye({fs:t,cache:e,gitdir:r,oid:n}),s=o.tree;if(i==="")n=o.oid;else{const h=i.split("/");n=await ls({fs:t,cache:e,gitdir:r,tree:s,pathArray:h,oid:a,filepath:i})}return n}async function ls({fs:t,cache:e,gitdir:r,tree:n,pathArray:i,oid:a,filepath:o}){const s=i.shift();for(const h of n)if(h.path===s){if(i.length===0)return h.oid;{const{type:l,object:f}=await rt({fs:t,cache:e,gitdir:r,oid:h.oid});if(l!=="tree")throw new yt(a,l,"tree",o);return n=vt.from(f),ls({fs:t,cache:e,gitdir:r,tree:n,pathArray:i,oid:a,filepath:o})}}throw new V(`file or directory found at "${a}:${o}"`)}async function ir({fs:t,cache:e,gitdir:r,oid:n,filepath:i=void 0}){i!==void 0&&(n=await Hr({fs:t,cache:e,gitdir:r,oid:n,filepath:i}));const{tree:a,oid:o}=await Ye({fs:t,cache:e,gitdir:r,oid:n});return{oid:o,tree:a.entries()}}async function Fi({fs:t,gitdir:e,tree:r}){const n=vt.from(r).toObject();return await St({fs:t,gitdir:e,type:"tree",object:n,format:"content"})}async function Tu({fs:t,cache:e,onSign:r,gitdir:n,ref:i,oid:a,note:o,force:s,author:h,committer:l,signingKey:f}){let d;try{d=await D.resolve({gitdir:n,fs:t,ref:i})}catch(x){if(!(x instanceof V))throw x}let m=(await ir({fs:t,cache:e,gitdir:n,oid:d||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(s)m=m.filter(x=>x.path!==a);else for(const x of m)if(x.path===a)throw new Nt("note",a);typeof o=="string"&&(o=Buffer.from(o,"utf8"));const g=await St({fs:t,gitdir:n,type:"blob",object:o,format:"content"});m.push({mode:"100644",path:a,oid:g,type:"blob"});const b=await Fi({fs:t,gitdir:n,tree:m});return await In({fs:t,cache:e,onSign:r,gitdir:n,ref:i,tree:b,parent:d&&[d],message:`Note added by 'isomorphic-git addNote'
`,author:h,committer:l,signingKey:f})}async function gi({fs:t,gitdir:e,path:r}){return(await pt.get({fs:t,gitdir:e})).get(r)}async function Oe({fs:t,gitdir:e,author:r={}}){let{name:n,email:i,timestamp:a,timezoneOffset:o}=r;if(n=n||await gi({fs:t,gitdir:e,path:"user.name"}),i=i||await gi({fs:t,gitdir:e,path:"user.email"})||"",n!==void 0)return a=a??Math.floor(Date.now()/1e3),o=o??new Date(a*1e3).getTimezoneOffset(),{name:n,email:i,timestamp:a,timezoneOffset:o}}async function Zr({fs:t,gitdir:e,author:r,committer:n}){return n=Object.assign({},n||r),r&&(n.timestamp=n.timestamp||r.timestamp,n.timezoneOffset=n.timezoneOffset||r.timezoneOffset),n=await Oe({fs:t,gitdir:e,author:n}),n}async function Ru({fs:t,onSign:e,dir:r,gitdir:n=F(r,".git"),ref:i="refs/notes/commits",oid:a,note:o,force:s,author:h,committer:l,signingKey:f,cache:d={}}){try{v("fs",t),v("gitdir",n),v("oid",a),v("note",o),f&&v("onSign",e);const p=new M(t),m=await Oe({fs:p,gitdir:n,author:h});if(!m)throw new gt("author");const g=await Zr({fs:p,gitdir:n,author:m,committer:l});if(!g)throw new gt("committer");return await Tu({fs:new M(p),cache:d,onSign:e,gitdir:n,ref:i,oid:a,note:o,force:s,author:m,committer:g,signingKey:f})}catch(p){throw p.caller="git.addNote",p}}async function us({fs:t,gitdir:e,remote:r,url:n,force:i}){if(r!==Wt.clean(r))throw new te(r,Wt.clean(r));const a=await pt.get({fs:t,gitdir:e});if(!i&&(await a.getSubsections("remote")).includes(r)&&n!==await a.get(`remote.${r}.url`))throw new Nt("remote",r);await a.set(`remote.${r}.url`,n),await a.set(`remote.${r}.fetch`,`+refs/heads/*:refs/remotes/${r}/*`),await pt.save({fs:t,gitdir:e,config:a})}async function Ou({fs:t,dir:e,gitdir:r=F(e,".git"),remote:n,url:i,force:a=!1}){try{return v("fs",t),v("gitdir",r),v("remote",n),v("url",i),await us({fs:new M(t),gitdir:r,remote:n,url:i,force:a})}catch(o){throw o.caller="git.addRemote",o}}async function Cu({fs:t,cache:e,onSign:r,gitdir:n,ref:i,tagger:a,message:o=i,gpgsig:s,object:h,signingKey:l,force:f=!1}){if(i=i.startsWith("refs/tags/")?i:`refs/tags/${i}`,!f&&await D.exists({fs:t,gitdir:n,ref:i}))throw new Nt("tag",i);const d=await D.resolve({fs:t,gitdir:n,ref:h||"HEAD"}),{type:p}=await rt({fs:t,cache:e,gitdir:n,oid:d});let m=_t.from({object:d,type:p,tag:i.replace("refs/tags/",""),tagger:a,message:o,gpgsig:s});l&&(m=await _t.sign(m,r,l));const g=await St({fs:t,gitdir:n,type:"tag",object:m.toObject()});await D.writeRef({fs:t,gitdir:n,ref:i,value:g})}async function Fu({fs:t,onSign:e,dir:r,gitdir:n=F(r,".git"),ref:i,tagger:a,message:o=i,gpgsig:s,object:h,signingKey:l,force:f=!1,cache:d={}}){try{v("fs",t),v("gitdir",n),v("ref",i),l&&v("onSign",e);const p=new M(t),m=await Oe({fs:p,gitdir:n,author:a});if(!m)throw new gt("tagger");return await Cu({fs:p,cache:d,onSign:e,gitdir:n,ref:i,tagger:m,message:o,gpgsig:s,object:h,signingKey:l,force:f})}catch(p){throw p.caller="git.annotatedTag",p}}async function Nu({fs:t,gitdir:e,ref:r,object:n,checkout:i=!1,force:a=!1}){if(r!==Wt.clean(r))throw new te(r,Wt.clean(r));const o=`refs/heads/${r}`;if(!a&&await D.exists({fs:t,gitdir:e,ref:o}))throw new Nt("branch",r,!1);let s;try{s=await D.resolve({fs:t,gitdir:e,ref:n||"HEAD"})}catch{}s&&await D.writeRef({fs:t,gitdir:e,ref:o,value:s}),i&&await D.writeSymbolicRef({fs:t,gitdir:e,ref:"HEAD",value:o})}async function Uu({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n,object:i,checkout:a=!1,force:o=!1}){try{return v("fs",t),v("gitdir",r),v("ref",n),await Nu({fs:new M(t),gitdir:r,ref:n,object:i,checkout:a,force:o})}catch(s){throw s.caller="git.branch",s}}const hs=(t,e)=>t==="."||e==null||e.length===0||e==="."?!0:e.length>=t.length?e.startsWith(t):t.startsWith(e);async function Ni({fs:t,cache:e,onProgress:r,dir:n,gitdir:i,remote:a,ref:o,filepaths:s,noCheckout:h,noUpdateHead:l,dryRun:f,force:d,track:p=!0}){let m;try{m=await D.resolve({fs:t,gitdir:i,ref:o})}catch(g){if(o==="HEAD")throw g;const b=`${a}/${o}`;if(m=await D.resolve({fs:t,gitdir:i,ref:b}),p){const E=await pt.get({fs:t,gitdir:i});await E.set(`branch.${o}.remote`,a),await E.set(`branch.${o}.merge`,`refs/heads/${o}`),await pt.save({fs:t,gitdir:i,config:E})}await D.writeRef({fs:t,gitdir:i,ref:`refs/heads/${o}`,value:m})}if(!h){let g;try{g=await Du({fs:t,cache:e,onProgress:r,dir:n,gitdir:i,ref:o,force:d,filepaths:s})}catch(A){throw A instanceof V&&A.data.what===m?new Or(o,m):A}const b=g.filter(([A])=>A==="conflict").map(([A,B])=>B);if(b.length>0)throw new Rr(b);const E=g.filter(([A])=>A==="error").map(([A,B])=>B);if(E.length>0)throw new j(E.join(", "));if(f)return;let x=0;const $=g.length;await dt.acquire({fs:t,gitdir:i,cache:e},async function(A){await Promise.all(g.filter(([B])=>B==="delete"||B==="delete-index").map(async function([B,S]){const U=`${n}/${S}`;B==="delete"&&await t.rm(U),A.delete({filepath:S}),r&&await r({phase:"Updating workdir",loaded:++x,total:$})}))}),await dt.acquire({fs:t,gitdir:i,cache:e},async function(A){for(const[B,S]of g)if(B==="rmdir"||B==="rmdir-index"){const U=`${n}/${S}`;try{B==="rmdir-index"&&A.delete({filepath:S}),await t.rmdir(U),r&&await r({phase:"Updating workdir",loaded:++x,total:$})}catch(O){if(O.code==="ENOTEMPTY")console.log(`Did not delete ${S} because directory is not empty`);else throw O}}}),await Promise.all(g.filter(([A])=>A==="mkdir"||A==="mkdir-index").map(async function([A,B]){const S=`${n}/${B}`;await t.mkdir(S),r&&await r({phase:"Updating workdir",loaded:++x,total:$})})),await dt.acquire({fs:t,gitdir:i,cache:e},async function(A){await Promise.all(g.filter(([B])=>B==="create"||B==="create-index"||B==="update"||B==="mkdir-index").map(async function([B,S,U,O,k]){const N=`${n}/${S}`;try{if(B!=="create-index"&&B!=="mkdir-index"){const{object:C}=await rt({fs:t,cache:e,gitdir:i,oid:U});if(k&&await t.rm(N),O===33188)await t.write(N,C);else if(O===33261)await t.write(N,C,{mode:511});else if(O===40960)await t.writelink(N,C);else throw new j(`Invalid mode 0o${O.toString(8)} detected in blob ${U}`)}const T=await t.lstat(N);O===33261&&(T.mode=493),B==="mkdir-index"&&(T.mode=57344),A.insert({filepath:S,stats:T,oid:U}),r&&await r({phase:"Updating workdir",loaded:++x,total:$})}catch(T){console.log(T)}}))})}if(!l){const g=await D.expand({fs:t,gitdir:i,ref:o});g.startsWith("refs/heads")?await D.writeSymbolicRef({fs:t,gitdir:i,ref:"HEAD",value:g}):await D.writeRef({fs:t,gitdir:i,ref:"HEAD",value:m})}}async function Du({fs:t,cache:e,onProgress:r,dir:n,gitdir:i,ref:a,force:o,filepaths:s}){let h=0;return Ke({fs:t,cache:e,dir:n,gitdir:i,trees:[we({ref:a}),Bn(),Sn()],map:async function(l,[f,d,p]){if(l===".")return;if(s&&!s.some(g=>hs(l,g)))return null;switch(r&&await r({phase:"Analyzing workdir",loaded:++h}),[!!p,!!f,!!d].map(Number).join("")){case"000":return;case"001":return o&&s&&s.includes(l)?["delete",l]:void 0;case"010":switch(await f.type()){case"tree":return["mkdir",l];case"blob":return["create",l,await f.oid(),await f.mode()];case"commit":return["mkdir-index",l,await f.oid(),await f.mode()];default:return["error",`new entry Unhandled type ${await f.type()}`]}case"011":switch(`${await f.type()}-${await d.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",l];case"blob-blob":return await f.oid()!==await d.oid()?o?["update",l,await f.oid(),await f.mode(),await f.mode()!==await d.mode()]:["conflict",l]:await f.mode()!==await d.mode()?o?["update",l,await f.oid(),await f.mode(),!0]:["conflict",l]:["create-index",l,await f.oid(),await f.mode()];case"commit-tree":return;case"commit-blob":return["conflict",l];default:return["error",`new entry Unhandled type ${f.type}`]}case"100":return["delete-index",l];case"101":switch(await p.type()){case"tree":return["rmdir",l];case"blob":return await p.oid()!==await d.oid()?o?["delete",l]:["conflict",l]:["delete",l];case"commit":return["rmdir-index",l];default:return["error",`delete entry Unhandled type ${await p.type()}`]}case"110":case"111":switch(`${await p.type()}-${await f.type()}`){case"tree-tree":return;case"blob-blob":{if(await p.oid()===await f.oid()&&await p.mode()===await f.mode()&&!o)return;if(d){if(await d.oid()!==await p.oid()&&await d.oid()!==await f.oid())return o?["update",l,await f.oid(),await f.mode(),await f.mode()!==await d.mode()]:["conflict",l]}else if(o)return["update",l,await f.oid(),await f.mode(),await f.mode()!==await p.mode()];return await f.mode()!==await p.mode()?["update",l,await f.oid(),await f.mode(),!0]:await f.oid()!==await p.oid()?["update",l,await f.oid(),await f.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",l,await f.oid()];case"blob-tree":return["update-blob-to-tree",l];case"commit-commit":return["mkdir-index",l,await f.oid(),await f.mode()];default:return["error",`update entry Unhandled type ${await p.type()}-${await f.type()}`]}}},reduce:async function(l,f){return f=ss(f),l?l&&l[0]==="rmdir"?(f.push(l),f):(f.unshift(l),f):f}})}async function Pu({fs:t,onProgress:e,dir:r,gitdir:n=F(r,".git"),remote:i="origin",ref:a,filepaths:o,noCheckout:s=!1,noUpdateHead:h=a===void 0,dryRun:l=!1,force:f=!1,track:d=!0,cache:p={}}){try{v("fs",t),v("dir",r),v("gitdir",n);const m=a||"HEAD";return await Ni({fs:new M(t),cache:p,onProgress:e,dir:r,gitdir:n,remote:i,ref:m,filepaths:o,noCheckout:s,noUpdateHead:h,dryRun:l,force:f,track:d})}catch(m){throw m.caller="git.checkout",m}}const zu=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function Me(t){const e=zu.exec(t);return e?e[1]==="remotes/"&&t.endsWith("/HEAD")?e[2].slice(0,-5):e[2]:t}async function Ce({fs:t,gitdir:e,fullname:r=!1,test:n=!1}){const i=await D.resolve({fs:t,gitdir:e,ref:"HEAD",depth:2});if(n)try{await D.resolve({fs:t,gitdir:e,ref:i})}catch{return}if(i.startsWith("refs/"))return r?i:Me(i)}function Mu(t){return t=t.replace(/^git@([^:]+):/,"https://$1/"),t=t.replace(/^ssh:\/\//,"https://"),t}function ds({username:t="",password:e=""}){return`Basic ${Buffer.from(`${t}:${e}`).toString("base64")}`}async function Gr(t,e){const r=is(t);for(;;){const{value:n,done:i}=await r.next();if(n&&await e(n),i)break}r.return&&r.return()}async function mn(t){let e=0;const r=[];await Gr(t,a=>{r.push(a),e+=a.byteLength});const n=new Uint8Array(e);let i=0;for(const a of r)n.set(a,i),i+=a.byteLength;return n}function qa(t){let e=t.match(/^https?:\/\/([^/]+)@/);if(e==null)return{url:t,auth:{}};e=e[1];const[r,n]=e.split(":");return t=t.replace(`${e}@`,""),{url:t,auth:{username:r,password:n}}}function yi(t,e){const r=e.toString(16);return"0".repeat(t-r.length)+r}class ot{static flush(){return Buffer.from("0000","utf8")}static delim(){return Buffer.from("0001","utf8")}static encode(e){typeof e=="string"&&(e=Buffer.from(e));const r=e.length+4,n=yi(4,r);return Buffer.concat([Buffer.from(n,"utf8"),e])}static streamReader(e){const r=new as(e);return async function(){try{let i=await r.read(4);if(i==null)return!0;if(i=parseInt(i.toString("utf8"),16),i===0||i===1)return null;const a=await r.read(i-4);return a??!0}catch(i){return console.log("error",i),!0}}}}async function Xa(t){const e={};let r;for(;r=await t(),r!==!0;){if(r===null)continue;r=r.toString("utf8").replace(/\n$/,"");const n=r.indexOf("=");if(n>-1){const i=r.slice(0,n),a=r.slice(n+1);e[i]=a}else e[r]=!0}return{protocolVersion:2,capabilities2:e}}async function Ya(t,{service:e}){const r=new Set,n=new Map,i=new Map,a=ot.streamReader(t);let o=await a();for(;o===null;)o=await a();if(o===!0)throw new Cr;if(o.includes("version 2"))return Xa(a);if(o.toString("utf8").replace(/\n$/,"")!==`# service=${e}`)throw new Re(`# service=${e}\\n`,o.toString("utf8"));let s=await a();for(;s===null;)s=await a();if(s===!0)return{capabilities:r,refs:n,symrefs:i};if(s=s.toString("utf8"),s.includes("version 2"))return Xa(a);const[h,l]=Jn(s,"\0","\\x00");l.split(" ").map(p=>r.add(p));const[f,d]=Jn(h," "," ");for(n.set(d,f);;){const p=await a();if(p===!0)break;if(p!==null){const[m,g]=Jn(p.toString("utf8")," "," ");n.set(g,m)}}for(const p of r)if(p.startsWith("symref=")){const m=p.match(/symref=([^:]+):(.*)/);m.length===3&&i.set(m[1],m[2])}return{protocolVersion:1,capabilities:r,refs:n,symrefs:i}}function Jn(t,e,r){const n=t.trim().split(e);if(n.length!==2)throw new Re(`Two strings separated by '${r}'`,t.toString("utf8"));return n}const Ka=(t,e)=>t.endsWith("?")?`${t}${e}`:`${t}/${e.replace(/^https?:\/\//,"")}`,Va=(t,e)=>{(e.username||e.password)&&(t.Authorization=ds(e)),e.headers&&Object.assign(t,e.headers)},ti=async t=>{try{const e=Buffer.from(await mn(t.body)),r=e.toString("utf8");return{preview:r.length<256?r:r.slice(0,256)+"...",response:r,data:e}}catch{return{}}};class _n{static async capabilities(){return["discover","connect"]}static async discover({http:e,onProgress:r,onAuth:n,onAuthSuccess:i,onAuthFailure:a,corsProxy:o,service:s,url:h,headers:l,protocolVersion:f}){let{url:d,auth:p}=qa(h);const m=o?Ka(o,d):d;(p.username||p.password)&&(l.Authorization=ds(p)),f===2&&(l["Git-Protocol"]="version=2");let g,b,E=!1;do if(g=await e.request({onProgress:r,method:"GET",url:`${m}/info/refs?service=${s}`,headers:l}),b=!1,g.statusCode===401||g.statusCode===203){const x=E?a:n;if(x){if(p=await x(d,{...p,headers:{...l}}),p&&p.cancel)throw new jr;p&&(Va(l,p),E=!0,b=!0)}}else g.statusCode===200&&E&&i&&await i(d,p);while(b);if(g.statusCode!==200){const{response:x}=await ti(g);throw new qe(g.statusCode,g.statusMessage,x)}if(g.headers["content-type"]===`application/x-${s}-advertisement`){const x=await Ya(g.body,{service:s});return x.auth=p,x}else{const{preview:x,response:$,data:A}=await ti(g);try{const B=await Ya([A],{service:s});return B.auth=p,B}catch{throw new Pr(x,$)}}}static async connect({http:e,onProgress:r,corsProxy:n,service:i,url:a,auth:o,body:s,headers:h}){const l=qa(a);l&&(a=l.url),n&&(a=Ka(n,a)),h["content-type"]=`application/x-${i}-request`,h.accept=`application/x-${i}-result`,Va(h,o);const f=await e.request({onProgress:r,method:"POST",url:`${a}/${i}`,body:s,headers:h});if(f.statusCode!==200){const{response:d}=ti(f);throw new qe(f.statusCode,f.statusMessage,d)}return f}}function ju({url:t}){if(t.startsWith("git@"))return{transport:"ssh",address:t};const e=t.match(/(\w+)(:\/\/|::)(.*)/);if(e!==null){if(e[2]==="://")return{transport:e[1],address:e[0]};if(e[2]==="::")return{transport:e[1],address:e[3]}}}class An{static getRemoteHelperFor({url:e}){const r=new Map;r.set("http",_n),r.set("https",_n);const n=ju({url:e});if(!n)throw new Mr(e);if(r.has(n.transport))return r.get(n.transport);throw new zr(e,n.transport,n.transport==="ssh"?Mu(e):void 0)}}let be=null;class xr{static async read({fs:e,gitdir:r}){be===null&&(be=new ni);const n=F(r,"shallow"),i=new Set;return await be.acquire(n,async function(){const a=await e.read(n,{encoding:"utf8"});if(a===null||a.trim()==="")return i;a.trim().split(`
`).map(o=>i.add(o))}),i}static async write({fs:e,gitdir:r,oids:n}){be===null&&(be=new ni);const i=F(r,"shallow");if(n.size>0){const a=[...n].join(`
`)+`
`;await be.acquire(i,async function(){await e.write(i,a,{encoding:"utf8"})})}else await be.acquire(i,async function(){await e.rm(i)})}}async function Lu({fs:t,gitdir:e,oid:r}){const n=`objects/${r.slice(0,2)}/${r.slice(2)}`;return t.exists(`${e}/${n}`)}async function Hu({fs:t,cache:e,gitdir:r,oid:n,getExternalRefDelta:i}){let a=await t.readdir(F(r,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const s=`${r}/objects/pack/${o}`,h=await Ci({fs:t,cache:e,filename:s,getExternalRefDelta:i});if(h.error)throw new j(h.error);if(h.offsets.has(n))return!0}return!1}async function Qa({fs:t,cache:e,gitdir:r,oid:n,format:i="content"}){const a=s=>rt({fs:t,cache:e,gitdir:r,oid:s});let o=await Lu({fs:t,gitdir:r,oid:n});return o||(o=await Hu({fs:t,cache:e,gitdir:r,oid:n,getExternalRefDelta:a})),o}function Zu(t){const e="5041434b",r="00000002",n="00000000",i=e+r+n;return t.slice(0,12).toString("hex")===i}function ws(t,e){const r=t.map(n=>n.split("=",1)[0]);return e.filter(n=>{const i=n.split("=",1)[0];return r.includes(i)})}const Tn={name:"isomorphic-git",version:"1.24.5",agent:"git/isomorphic-git@1.24.5"};class on{constructor(){this._queue=[]}write(e){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const r=this._waiting;this._waiting=null,r({value:e})}else this._queue.push(e)}end(){if(this._ended=!0,this._waiting){const e=this._waiting;this._waiting=null,e({done:!0})}}destroy(e){this._ended=!0,this.error=e}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(e=>{this._waiting=e})}}function Gu(t){const e=t.indexOf("\r"),r=t.indexOf(`
`);return e===-1&&r===-1?-1:e===-1?r+1:r===-1?e+1:r===e+1?r+1:Math.min(e,r)+1}function ps(t){const e=new on;let r="";return(async()=>(await Gr(t,n=>{for(n=n.toString("utf8"),r+=n;;){const i=Gu(r);if(i===-1)break;e.write(r.slice(0,i)),r=r.slice(i)}}),r.length>0&&e.write(r),e.end()))(),e}class ms{static demux(e){const r=ot.streamReader(e),n=new on,i=new on,a=new on,o=async function(){const s=await r();if(s===null)return o();if(s===!0){n.end(),a.end(),i.end();return}switch(s[0]){case 1:{i.write(s.slice(1));break}case 2:{a.write(s.slice(1));break}case 3:{const h=s.slice(1);a.write(h),i.destroy(new Error(h.toString("utf8")));return}default:n.write(s.slice(0))}o()};return o(),{packetlines:n,packfile:i,progress:a}}}async function Wu(t){const{packetlines:e,packfile:r,progress:n}=ms.demux(t),i=[],a=[],o=[];let s=!1,h=!1;return new Promise((l,f)=>{Gr(e,d=>{const p=d.toString("utf8").trim();if(p.startsWith("shallow")){const m=p.slice(-41).trim();m.length!==40&&f(new me(m)),i.push(m)}else if(p.startsWith("unshallow")){const m=p.slice(-41).trim();m.length!==40&&f(new me(m)),a.push(m)}else if(p.startsWith("ACK")){const[,m,g]=p.split(" ");o.push({oid:m,status:g}),g||(h=!0)}else p.startsWith("NAK")&&(s=!0,h=!0);h&&l({shallows:i,unshallows:a,acks:o,nak:s,packfile:r,progress:n})})})}function qu({capabilities:t=[],wants:e=[],haves:r=[],shallows:n=[],depth:i=null,since:a=null,exclude:o=[]}){const s=[];e=[...new Set(e)];let h=` ${t.join(" ")}`;for(const l of e)s.push(ot.encode(`want ${l}${h}
`)),h="";for(const l of n)s.push(ot.encode(`shallow ${l}
`));i!==null&&s.push(ot.encode(`deepen ${i}
`)),a!==null&&s.push(ot.encode(`deepen-since ${Math.floor(a.valueOf()/1e3)}
`));for(const l of o)s.push(ot.encode(`deepen-not ${l}
`));s.push(ot.flush());for(const l of r)s.push(ot.encode(`have ${l}
`));return s.push(ot.encode(`done
`)),s}async function Ui({fs:t,cache:e,http:r,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:o,onAuthFailure:s,gitdir:h,ref:l,remoteRef:f,remote:d,url:p,corsProxy:m,depth:g=null,since:b=null,exclude:E=[],relative:x=!1,tags:$=!1,singleBranch:A=!1,headers:B={},prune:S=!1,pruneTags:U=!1}){const O=l||await Ce({fs:t,gitdir:h,test:!0}),k=await pt.get({fs:t,gitdir:h}),N=d||O&&await k.get(`branch.${O}.remote`)||"origin",T=p||await k.get(`remote.${N}.url`);if(typeof T>"u")throw new kt("remote OR url");const C=f||O&&await k.get(`branch.${O}.merge`)||l||"HEAD";m===void 0&&(m=await k.get("http.corsProxy"));const P=An.getRemoteHelperFor({url:T}),z=await P.discover({http:r,onAuth:a,onAuthSuccess:o,onAuthFailure:s,corsProxy:m,service:"git-upload-pack",url:T,headers:B,protocolVersion:1}),G=z.auth,ut=z.refs;if(ut.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(g!==null&&!z.capabilities.has("shallow"))throw new de("shallow","depth");if(b!==null&&!z.capabilities.has("deepen-since"))throw new de("deepen-since","since");if(E.length>0&&!z.capabilities.has("deepen-not"))throw new de("deepen-not","exclude");if(x===!0&&!z.capabilities.has("deepen-relative"))throw new de("deepen-relative","relative");const{oid:Ut,fullref:wt}=D.resolveAgainstMap({ref:C,map:ut});for(const X of ut.keys())X===wt||X==="HEAD"||X.startsWith("refs/heads/")||$&&X.startsWith("refs/tags/")||ut.delete(X);const Ot=ws([...z.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${Tn.agent}`]);x&&Ot.push("deepen-relative");const ar=A?[Ut]:ut.values(),Bt=A?[O]:await D.listRefs({fs:t,gitdir:h,filepath:"refs"});let L=[];for(let X of Bt)try{X=await D.expand({fs:t,gitdir:h,ref:X});const Q=await D.resolve({fs:t,gitdir:h,ref:X});await Qa({fs:t,cache:e,gitdir:h,oid:Q})&&L.push(Q)}catch{}L=[...new Set(L)];const Y=await xr.read({fs:t,gitdir:h}),ct=z.capabilities.has("shallow")?[...Y]:[],re=qu({capabilities:Ot,wants:ar,haves:L,shallows:ct,depth:g,since:b,exclude:E}),Fe=Buffer.from(await mn(re)),ne=await P.connect({http:r,onProgress:n,corsProxy:m,service:"git-upload-pack",url:T,auth:G,body:[Fe],headers:B}),st=await Wu(ne.body);ne.headers&&(st.headers=ne.headers);for(const X of st.shallows)if(!Y.has(X))try{const{object:Q}=await rt({fs:t,cache:e,gitdir:h,oid:X}),lt=new et(Q),$t=await Promise.all(lt.headers().parent.map(Xt=>Qa({fs:t,cache:e,gitdir:h,oid:Xt})));$t.length===0||$t.every(Xt=>Xt)||Y.add(X)}catch{Y.add(X)}for(const X of st.unshallows)Y.delete(X);if(await xr.write({fs:t,gitdir:h,oids:Y}),A){const X=new Map([[wt,Ut]]),Q=new Map;let lt=10,$t=wt;for(;lt--;){const cr=z.symrefs.get($t);if(cr===void 0)break;Q.set($t,cr),$t=cr}const sr=ut.get($t);sr&&X.set($t,sr);const{pruned:Xt}=await D.updateRemoteRefs({fs:t,gitdir:h,remote:N,refs:X,symrefs:Q,tags:$,prune:S});S&&(st.pruned=Xt)}else{const{pruned:X}=await D.updateRemoteRefs({fs:t,gitdir:h,remote:N,refs:ut,symrefs:z.symrefs,tags:$,prune:S,pruneTags:U});S&&(st.pruned=X)}if(st.HEAD=z.symrefs.get("HEAD"),st.HEAD===void 0){const{oid:X}=D.resolveAgainstMap({ref:"HEAD",map:ut});for(const[Q,lt]of ut.entries())if(Q!=="HEAD"&&lt===X){st.HEAD=Q;break}}const ie=wt.startsWith("refs/tags")?"tag":"branch";if(st.FETCH_HEAD={oid:Ut,description:`${ie} '${Me(wt)}' of ${T}`},n||i){const X=ps(st.progress);Gr(X,async Q=>{if(i&&await i(Q),n){const lt=Q.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);lt&&await n({phase:lt[1].trim(),loaded:parseInt(lt[2],10),total:parseInt(lt[3],10)})}})}const ae=Buffer.from(await mn(st.packfile)),or=ae.slice(-20).toString("hex"),ye={defaultBranch:st.HEAD,fetchHead:st.FETCH_HEAD.oid,fetchHeadDescription:st.FETCH_HEAD.description};if(st.headers&&(ye.headers=st.headers),S&&(ye.pruned=st.pruned),or!==""&&!Zu(ae)){ye.packfile=`objects/pack/pack-${or}.pack`;const X=F(h,ye.packfile);await t.write(X,ae);const Q=$t=>rt({fs:t,cache:e,gitdir:h,oid:$t}),lt=await We.fromPack({pack:ae,getExternalRefDelta:Q,onProgress:n});await t.write(X.replace(/\.pack$/,".idx"),await lt.toBuffer())}return ye}async function _s({fs:t,bare:e=!1,dir:r,gitdir:n=e?r:F(r,".git"),defaultBranch:i="master"}){if(await t.exists(n+"/config"))return;let a=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];a=a.map(o=>n+"/"+o);for(const o of a)await t.mkdir(o);await t.write(n+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${e}
`+(e?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await t.write(n+"/HEAD",`ref: refs/heads/${i}
`)}async function Xu({fs:t,cache:e,http:r,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:o,onAuthFailure:s,dir:h,gitdir:l,url:f,corsProxy:d,ref:p,remote:m,depth:g,since:b,exclude:E,relative:x,singleBranch:$,noCheckout:A,noTags:B,headers:S}){try{if(await _s({fs:t,gitdir:l}),await us({fs:t,gitdir:l,remote:m,url:f,force:!1}),d){const k=await pt.get({fs:t,gitdir:l});await k.set("http.corsProxy",d),await pt.save({fs:t,gitdir:l,config:k})}const{defaultBranch:U,fetchHead:O}=await Ui({fs:t,cache:e,http:r,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:o,onAuthFailure:s,gitdir:l,ref:p,remote:m,corsProxy:d,depth:g,since:b,exclude:E,relative:x,singleBranch:$,headers:S,tags:!B});if(O===null)return;p=p||U,p=p.replace("refs/heads/",""),await Ni({fs:t,cache:e,onProgress:n,dir:h,gitdir:l,ref:p,remote:m,noCheckout:A})}catch(U){throw await t.rmdir(l,{recursive:!0,maxRetries:10}).catch(()=>{}),U}}async function Yu({fs:t,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h=F(s,".git"),url:l,corsProxy:f=void 0,ref:d=void 0,remote:p="origin",depth:m=void 0,since:g=void 0,exclude:b=[],relative:E=!1,singleBranch:x=!1,noCheckout:$=!1,noTags:A=!1,headers:B={},cache:S={}}){try{return v("fs",t),v("http",e),v("gitdir",h),$||v("dir",s),v("url",l),await Xu({fs:new M(t),cache:S,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h,url:l,corsProxy:f,ref:d,remote:p,depth:m,since:g,exclude:b,relative:E,singleBranch:x,noCheckout:$,noTags:A,headers:B})}catch(U){throw U.caller="git.clone",U}}async function Ku({fs:t,onSign:e,dir:r,gitdir:n=F(r,".git"),message:i,author:a,committer:o,signingKey:s,dryRun:h=!1,noUpdateBranch:l=!1,ref:f,parent:d,tree:p,cache:m={}}){try{v("fs",t),v("message",i),s&&v("onSign",e);const g=new M(t),b=await Oe({fs:g,gitdir:n,author:a});if(!b)throw new gt("author");const E=await Zr({fs:g,gitdir:n,author:b,committer:o});if(!E)throw new gt("committer");return await In({fs:g,cache:m,onSign:e,gitdir:n,message:i,author:b,committer:E,signingKey:s,dryRun:h,noUpdateBranch:l,ref:f,parent:d,tree:p})}catch(g){throw g.caller="git.commit",g}}async function Vu({fs:t,dir:e,gitdir:r=F(e,".git"),fullname:n=!1,test:i=!1}){try{return v("fs",t),v("gitdir",r),await Ce({fs:new M(t),gitdir:r,fullname:n,test:i})}catch(a){throw a.caller="git.currentBranch",a}}async function Qu({fs:t,gitdir:e,ref:r}){if(r=r.startsWith("refs/heads/")?r:`refs/heads/${r}`,!await D.exists({fs:t,gitdir:e,ref:r}))throw new V(r);const i=await D.expand({fs:t,gitdir:e,ref:r}),a=await Ce({fs:t,gitdir:e,fullname:!0});if(i===a){const o=await D.resolve({fs:t,gitdir:e,ref:i});await D.writeRef({fs:t,gitdir:e,ref:"HEAD",value:o})}await D.deleteRef({fs:t,gitdir:e,ref:i})}async function Ju({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n}){try{return v("fs",t),v("ref",n),await Qu({fs:new M(t),gitdir:r,ref:n})}catch(i){throw i.caller="git.deleteBranch",i}}async function th({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n}){try{v("fs",t),v("ref",n),await D.deleteRef({fs:new M(t),gitdir:r,ref:n})}catch(i){throw i.caller="git.deleteRef",i}}async function eh({fs:t,gitdir:e,remote:r}){const n=await pt.get({fs:t,gitdir:e});await n.deleteSection("remote",r),await pt.save({fs:t,gitdir:e,config:n})}async function rh({fs:t,dir:e,gitdir:r=F(e,".git"),remote:n}){try{return v("fs",t),v("remote",n),await eh({fs:new M(t),gitdir:r,remote:n})}catch(i){throw i.caller="git.deleteRemote",i}}async function nh({fs:t,gitdir:e,ref:r}){r=r.startsWith("refs/tags/")?r:`refs/tags/${r}`,await D.deleteRef({fs:t,gitdir:e,ref:r})}async function ih({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n}){try{return v("fs",t),v("ref",n),await nh({fs:new M(t),gitdir:r,ref:n})}catch(i){throw i.caller="git.deleteTag",i}}async function ah({fs:t,gitdir:e,oid:r}){const n=r.slice(0,2);return(await t.readdir(`${e}/objects/${n}`)).map(a=>`${n}${a}`).filter(a=>a.startsWith(r))}async function oh({fs:t,cache:e,gitdir:r,oid:n,getExternalRefDelta:i}){const a=[];let o=await t.readdir(F(r,"objects/pack"));o=o.filter(s=>s.endsWith(".idx"));for(const s of o){const h=`${r}/objects/pack/${s}`,l=await Ci({fs:t,cache:e,filename:h,getExternalRefDelta:i});if(l.error)throw new j(l.error);for(const f of l.offsets.keys())f.startsWith(n)&&a.push(f)}return a}async function sh({fs:t,cache:e,gitdir:r,oid:n}){const i=s=>rt({fs:t,cache:e,gitdir:r,oid:s}),a=await ah({fs:t,gitdir:r,oid:n}),o=await oh({fs:t,cache:e,gitdir:r,oid:n,getExternalRefDelta:i});for(const s of o)a.indexOf(s)===-1&&a.push(s);if(a.length===1)return a[0];throw a.length>1?new Tr("oids",n,a):new V(`an object matching "${n}"`)}async function ch({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,cache:i={}}){try{return v("fs",t),v("gitdir",r),v("oid",n),await sh({fs:new M(t),cache:i,gitdir:r,oid:n})}catch(a){throw a.caller="git.expandOid",a}}async function fh({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n}){try{return v("fs",t),v("gitdir",r),v("ref",n),await D.expand({fs:new M(t),gitdir:r,ref:n})}catch(i){throw i.caller="git.expandRef",i}}async function Di({fs:t,cache:e,gitdir:r,oids:n}){const i={},a=n.length;let o=n.map((s,h)=>({index:h,oid:s}));for(;o.length;){const s=new Set;for(const{oid:l,index:f}of o)i[l]||(i[l]=new Set),i[l].add(f),i[l].size===a&&s.add(l);if(s.size>0)return[...s];const h=new Map;for(const{oid:l,index:f}of o)try{const{object:d}=await rt({fs:t,cache:e,gitdir:r,oid:l}),p=et.from(d),{parent:m}=p.parseHeaders();for(const g of m)(!i[g]||!i[g].has(f))&&h.set(g+":"+f,{oid:g,index:f})}catch{}o=Array.from(h.values())}return[]}const ei=/^.*(\r?\n|$)/gm;function lh({branches:t,contents:e}){const r=t[1],n=t[2],i=e[0],a=e[1],o=e[2],s=a.match(ei),h=i.match(ei),l=o.match(ei),f=Bl(s,h,l),d=7;let p="",m=!0;for(const g of f)g.ok&&(p+=g.ok.join("")),g.conflict&&(m=!1,p+=`${"<".repeat(d)} ${r}
`,p+=g.conflict.a.join(""),p+=`${"=".repeat(d)}
`,p+=g.conflict.b.join(""),p+=`${">".repeat(d)} ${n}
`);return{cleanMerge:m,mergedText:p}}async function uh({fs:t,cache:e,dir:r,gitdir:n=F(r,".git"),index:i,ourOid:a,baseOid:o,theirOid:s,ourName:h="ours",baseName:l="base",theirName:f="theirs",dryRun:d=!1,abortOnConflict:p=!0,mergeDriver:m}){const g=we({ref:a}),b=we({ref:o}),E=we({ref:s}),x=[],$=await Ke({fs:t,cache:e,dir:r,gitdir:n,trees:[g,b,E],map:async function(A,[B,S,U]){const O=un(A),k=await pn(B,S),N=await pn(U,S);switch(`${k}-${N}`){case"false-false":return{mode:await S.mode(),path:O,oid:await S.oid(),type:await S.type()};case"false-true":return U?{mode:await U.mode(),path:O,oid:await U.oid(),type:await U.type()}:void 0;case"true-false":return B?{mode:await B.mode(),path:O,oid:await B.oid(),type:await B.type()}:void 0;case"true-true":{if(B&&S&&U&&await B.type()==="blob"&&await S.type()==="blob"&&await U.type()==="blob")return hh({fs:t,gitdir:n,path:O,ours:B,base:S,theirs:U,ourName:h,baseName:l,theirName:f,mergeDriver:m}).then(async T=>{if(T.cleanMerge)p||i.insert({filepath:A,oid:T.mergeResult.oid,stage:0});else if(x.push(A),!p){const C=await S.oid(),P=await B.oid(),z=await U.oid();i.delete({filepath:A}),i.insert({filepath:A,oid:C,stage:1}),i.insert({filepath:A,oid:P,stage:2}),i.insert({filepath:A,oid:z,stage:3})}return T.mergeResult});throw new rr}}},reduce:x.length!==0&&(!r||p)?void 0:async(A,B)=>{const S=B.filter(Boolean);if(A&&!(A&&A.type==="tree"&&S.length===0)){if(S.length>0){const O=new vt(S).toObject(),k=await St({fs:t,gitdir:n,type:"tree",object:O,dryRun:d});A.oid=k}return A}}});return x.length!==0?(r&&!p&&await Ke({fs:t,cache:e,dir:r,gitdir:n,trees:[we({ref:$.oid})],map:async function(A,[B]){const S=`${r}/${A}`;if(await B.type()==="blob"){const U=await B.mode(),O=new TextDecoder().decode(await B.content());await t.write(S,O,{mode:U})}return!0}}),new nr(x)):$.oid}async function hh({fs:t,gitdir:e,path:r,ours:n,base:i,theirs:a,ourName:o,theirName:s,baseName:h,dryRun:l,mergeDriver:f=lh}){const d="blob",p=await i.mode()===await n.mode()?await a.mode():await n.mode();if(await n.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:p,path:r,oid:await n.oid(),type:d}};if(await n.oid()===await i.oid())return{cleanMerge:!0,mergeResult:{mode:p,path:r,oid:await a.oid(),type:d}};if(await a.oid()===await i.oid())return{cleanMerge:!0,mergeResult:{mode:p,path:r,oid:await n.oid(),type:d}};const m=Buffer.from(await n.content()).toString("utf8"),g=Buffer.from(await i.content()).toString("utf8"),b=Buffer.from(await a.content()).toString("utf8"),{mergedText:E,cleanMerge:x}=await f({branches:[h,o,s],contents:[g,m,b],path:r}),$=await St({fs:t,gitdir:e,type:"blob",object:Buffer.from(E,"utf8"),dryRun:l});return{cleanMerge:x,mergeResult:{mode:p,path:r,oid:$,type:d}}}async function gs({fs:t,cache:e,dir:r,gitdir:n,ours:i,theirs:a,fastForward:o=!0,fastForwardOnly:s=!1,dryRun:h=!1,noUpdateBranch:l=!1,abortOnConflict:f=!0,message:d,author:p,committer:m,signingKey:g,onSign:b,mergeDriver:E}){i===void 0&&(i=await Ce({fs:t,gitdir:n,fullname:!0})),i=await D.expand({fs:t,gitdir:n,ref:i}),a=await D.expand({fs:t,gitdir:n,ref:a});const x=await D.resolve({fs:t,gitdir:n,ref:i}),$=await D.resolve({fs:t,gitdir:n,ref:a}),A=await Di({fs:t,cache:e,gitdir:n,oids:[x,$]});if(A.length!==1)throw new rr;const B=A[0];if(B===$)return{oid:x,alreadyMerged:!0};if(o&&B===x)return!h&&!l&&await D.writeRef({fs:t,gitdir:n,ref:i,value:$}),{oid:$,fastForward:!0};{if(s)throw new Fr;const S=await dt.acquire({fs:t,gitdir:n,cache:e,allowUnmerged:!1},async O=>uh({fs:t,cache:e,dir:r,gitdir:n,index:O,ourOid:x,theirOid:$,baseOid:B,ourName:Me(i),baseName:"base",theirName:Me(a),dryRun:h,abortOnConflict:f,mergeDriver:E}));if(S instanceof nr)throw S;return d||(d=`Merge branch '${Me(a)}' into ${Me(i)}`),{oid:await In({fs:t,cache:e,gitdir:n,message:d,ref:i,tree:S,parent:[x,$],author:p,committer:m,signingKey:g,onSign:b,dryRun:h,noUpdateBranch:l}),tree:S,mergeCommit:!0}}}async function ys({fs:t,cache:e,http:r,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:o,onAuthFailure:s,dir:h,gitdir:l,ref:f,url:d,remote:p,remoteRef:m,prune:g,pruneTags:b,fastForward:E,fastForwardOnly:x,corsProxy:$,singleBranch:A,headers:B,author:S,committer:U,signingKey:O}){try{if(!f){const T=await Ce({fs:t,gitdir:l});if(!T)throw new kt("ref");f=T}const{fetchHead:k,fetchHeadDescription:N}=await Ui({fs:t,cache:e,http:r,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:o,onAuthFailure:s,gitdir:l,corsProxy:$,ref:f,url:d,remote:p,remoteRef:m,singleBranch:A,headers:B,prune:g,pruneTags:b});await gs({fs:t,cache:e,gitdir:l,ours:f,theirs:k,fastForward:E,fastForwardOnly:x,message:`Merge ${N}`,author:S,committer:U,signingKey:O,dryRun:!1,noUpdateBranch:!1}),await Ni({fs:t,cache:e,onProgress:n,dir:h,gitdir:l,ref:f,remote:p,noCheckout:!1})}catch(k){throw k.caller="git.pull",k}}async function dh({fs:t,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h=F(s,".git"),ref:l,url:f,remote:d,remoteRef:p,corsProxy:m,singleBranch:g,headers:b={},cache:E={}}){try{v("fs",t),v("http",e),v("gitdir",h);const x={name:"",email:"",timestamp:Date.now(),timezoneOffset:0};return await ys({fs:new M(t),cache:E,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h,ref:l,url:f,remote:d,remoteRef:p,fastForwardOnly:!0,corsProxy:m,singleBranch:g,headers:b,author:x,committer:x})}catch(x){throw x.caller="git.fastForward",x}}async function wh({fs:t,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h=F(s,".git"),ref:l,remote:f,remoteRef:d,url:p,corsProxy:m,depth:g=null,since:b=null,exclude:E=[],relative:x=!1,tags:$=!1,singleBranch:A=!1,headers:B={},prune:S=!1,pruneTags:U=!1,cache:O={}}){try{return v("fs",t),v("http",e),v("gitdir",h),await Ui({fs:new M(t),cache:O,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,gitdir:h,ref:l,remote:f,remoteRef:d,url:p,corsProxy:m,depth:g,since:b,exclude:E,relative:x,tags:$,singleBranch:A,headers:B,prune:S,pruneTags:U})}catch(k){throw k.caller="git.fetch",k}}async function ph({fs:t,dir:e,gitdir:r=F(e,".git"),oids:n,cache:i={}}){try{return v("fs",t),v("gitdir",r),v("oids",n),await Di({fs:new M(t),cache:i,gitdir:r,oids:n})}catch(a){throw a.caller="git.findMergeBase",a}}async function bs({fs:t,filepath:e}){if(await t.exists(F(e,".git")))return e;{const r=Ge(e);if(r===e)throw new V(`git root for ${e}`);return bs({fs:t,filepath:r})}}async function mh({fs:t,filepath:e}){try{return v("fs",t),v("filepath",e),await bs({fs:new M(t),filepath:e})}catch(r){throw r.caller="git.findRoot",r}}async function _h({fs:t,dir:e,gitdir:r=F(e,".git"),path:n}){try{return v("fs",t),v("gitdir",r),v("path",n),await gi({fs:new M(t),gitdir:r,path:n})}catch(i){throw i.caller="git.getConfig",i}}async function gh({fs:t,gitdir:e,path:r}){return(await pt.get({fs:t,gitdir:e})).getall(r)}async function yh({fs:t,dir:e,gitdir:r=F(e,".git"),path:n}){try{return v("fs",t),v("gitdir",r),v("path",n),await gh({fs:new M(t),gitdir:r,path:n})}catch(i){throw i.caller="git.getConfigAll",i}}async function bh({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:n,corsProxy:i,url:a,headers:o={},forPush:s=!1}){try{v("http",t),v("url",a);const l=await An.getRemoteHelperFor({url:a}).discover({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:n,corsProxy:i,service:s?"git-receive-pack":"git-upload-pack",url:a,headers:o,protocolVersion:1}),f={capabilities:[...l.capabilities]};for(const[d,p]of l.refs){const m=d.split("/"),g=m.pop();let b=f;for(const E of m)b[E]=b[E]||{},b=b[E];b[g]=p}for(const[d,p]of l.symrefs){const m=d.split("/"),g=m.pop();let b=f;for(const E of m)b[E]=b[E]||{},b=b[E];b[g]=p}return f}catch(h){throw h.caller="git.getRemoteInfo",h}}function vs(t,e,r,n){const i=[];for(const[a,o]of t.refs){if(e&&!a.startsWith(e))continue;if(a.endsWith("^{}")){if(n){const h=a.replace("^{}",""),l=i[i.length-1],f=l.ref===h?l:i.find(d=>d.ref===h);if(f===void 0)throw new Error("I did not expect this to happen");f.peeled=o}continue}const s={ref:a,oid:o};r&&t.symrefs.has(a)&&(s.target=t.symrefs.get(a)),i.push(s)}return i}async function vh({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:n,corsProxy:i,url:a,headers:o={},forPush:s=!1,protocolVersion:h=2}){try{v("http",t),v("url",a);const f=await An.getRemoteHelperFor({url:a}).discover({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:n,corsProxy:i,service:s?"git-receive-pack":"git-upload-pack",url:a,headers:o,protocolVersion:h});if(f.protocolVersion===2)return{protocolVersion:f.protocolVersion,capabilities:f.capabilities2};const d={};for(const p of f.capabilities){const[m,g]=p.split("=");g?d[m]=g:d[m]=!0}return{protocolVersion:1,capabilities:d,refs:vs(f,void 0,!0,!0)}}catch(l){throw l.caller="git.getRemoteInfo2",l}}async function xh({type:t,object:e,format:r="content",oid:n=void 0}){return r!=="deflated"&&(r!=="wrapped"&&(e=er.wrap({type:t,object:e})),n=await Jt(e)),{oid:n,object:e}}async function Eh({object:t}){try{v("object",t),typeof t=="string"?t=Buffer.from(t,"utf8"):t=Buffer.from(t);const e="blob",{oid:r,object:n}=await xh({type:"blob",format:"content",object:t});return{oid:r,type:e,object:new Uint8Array(n),format:"wrapped"}}catch(e){throw e.caller="git.hashBlob",e}}async function kh({fs:t,cache:e,onProgress:r,dir:n,gitdir:i,filepath:a}){try{a=F(n,a);const o=await t.read(a),s=l=>rt({fs:t,cache:e,gitdir:i,oid:l}),h=await We.fromPack({pack:o,getExternalRefDelta:s,onProgress:r});return await t.write(a.replace(/\.pack$/,".idx"),await h.toBuffer()),{oids:[...h.hashes]}}catch(o){throw o.caller="git.indexPack",o}}async function Sh({fs:t,onProgress:e,dir:r,gitdir:n=F(r,".git"),filepath:i,cache:a={}}){try{return v("fs",t),v("dir",r),v("gitdir",r),v("filepath",i),await kh({fs:new M(t),cache:a,onProgress:e,dir:r,gitdir:n,filepath:i})}catch(o){throw o.caller="git.indexPack",o}}async function Bh({fs:t,bare:e=!1,dir:r,gitdir:n=e?r:F(r,".git"),defaultBranch:i="master"}){try{return v("fs",t),v("gitdir",n),e||v("dir",r),await _s({fs:new M(t),bare:e,dir:r,gitdir:n,defaultBranch:i})}catch(a){throw a.caller="git.init",a}}async function xs({fs:t,cache:e,gitdir:r,oid:n,ancestor:i,depth:a}){const o=await xr.read({fs:t,gitdir:r});if(!n)throw new kt("oid");if(!i)throw new kt("ancestor");if(n===i)return!1;const s=[n],h=new Set;let l=0;for(;s.length;){if(l++===a)throw new Ur(a);const f=s.shift(),{type:d,object:p}=await rt({fs:t,cache:e,gitdir:r,oid:f});if(d!=="commit")throw new yt(f,d,"commit");const m=et.from(p).parse();for(const g of m.parent)if(g===i)return!0;if(!o.has(f))for(const g of m.parent)h.has(g)||(s.push(g),h.add(g))}return!1}async function $h({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,ancestor:i,depth:a=-1,cache:o={}}){try{return v("fs",t),v("gitdir",r),v("oid",n),v("ancestor",i),await xs({fs:new M(t),cache:o,gitdir:r,oid:n,ancestor:i,depth:a})}catch(s){throw s.caller="git.isDescendent",s}}async function Ih({fs:t,dir:e,gitdir:r=F(e,".git"),filepath:n}){try{return v("fs",t),v("dir",e),v("gitdir",r),v("filepath",n),$n.isIgnored({fs:new M(t),dir:e,gitdir:r,filepath:n})}catch(i){throw i.caller="git.isIgnored",i}}async function Ah({fs:t,dir:e,gitdir:r=F(e,".git"),remote:n}){try{return v("fs",t),v("gitdir",r),D.listBranches({fs:new M(t),gitdir:r,remote:n})}catch(i){throw i.caller="git.listBranches",i}}async function Th({fs:t,gitdir:e,ref:r,cache:n}){if(r){const i=await D.resolve({gitdir:e,fs:t,ref:r}),a=[];return await Es({fs:t,cache:n,gitdir:e,oid:i,filenames:a,prefix:""}),a}else return dt.acquire({fs:t,gitdir:e,cache:n},async function(i){return i.entries.map(a=>a.path)})}async function Es({fs:t,cache:e,gitdir:r,oid:n,filenames:i,prefix:a}){const{tree:o}=await ir({fs:t,cache:e,gitdir:r,oid:n});for(const s of o)s.type==="tree"?await Es({fs:t,cache:e,gitdir:r,oid:s.oid,filenames:i,prefix:F(a,s.path)}):i.push(F(a,s.path))}async function Rh({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n,cache:i={}}){try{return v("fs",t),v("gitdir",r),await Th({fs:new M(t),cache:i,gitdir:r,ref:n})}catch(a){throw a.caller="git.listFiles",a}}async function Oh({fs:t,cache:e,gitdir:r,ref:n}){let i;try{i=await D.resolve({gitdir:r,fs:t,ref:n})}catch(s){if(s instanceof V)return[]}return(await ir({fs:t,cache:e,gitdir:r,oid:i})).tree.map(s=>({target:s.path,note:s.oid}))}async function Ch({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n="refs/notes/commits",cache:i={}}){try{return v("fs",t),v("gitdir",r),v("ref",n),await Oh({fs:new M(t),cache:i,gitdir:r,ref:n})}catch(a){throw a.caller="git.listNotes",a}}async function Fh({fs:t,gitdir:e}){const r=await pt.get({fs:t,gitdir:e}),n=await r.getSubsections("remote");return Promise.all(n.map(async a=>{const o=await r.get(`remote.${a}.url`);return{remote:a,url:o}}))}async function Nh({fs:t,dir:e,gitdir:r=F(e,".git")}){try{return v("fs",t),v("gitdir",r),await Fh({fs:new M(t),gitdir:r})}catch(n){throw n.caller="git.listRemotes",n}}async function Uh(t){const e=ot.streamReader(t),r=[];let n;for(;n=await e(),n!==!0;){if(n===null)continue;n=n.toString("utf8").replace(/\n$/,"");const[i,a,...o]=n.split(" "),s={ref:a,oid:i};for(const h of o){const[l,f]=h.split(":");l==="symref-target"?s.target=f:l==="peeled"&&(s.peeled=f)}r.push(s)}return r}async function Dh({prefix:t,symrefs:e,peelTags:r}){const n=[];return n.push(ot.encode(`command=ls-refs
`)),n.push(ot.encode(`agent=${Tn.agent}
`)),(r||e||t)&&n.push(ot.delim()),r&&n.push(ot.encode("peel")),e&&n.push(ot.encode("symrefs")),t&&n.push(ot.encode(`ref-prefix ${t}`)),n.push(ot.flush()),n}async function Ph({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:n,corsProxy:i,url:a,headers:o={},forPush:s=!1,protocolVersion:h=2,prefix:l,symrefs:f,peelTags:d}){try{v("http",t),v("url",a);const p=await _n.discover({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:n,corsProxy:i,service:s?"git-receive-pack":"git-upload-pack",url:a,headers:o,protocolVersion:h});if(p.protocolVersion===1)return vs(p,l,f,d);const m=await Dh({prefix:l,symrefs:f,peelTags:d}),g=await _n.connect({http:t,auth:p.auth,headers:o,corsProxy:i,service:s?"git-receive-pack":"git-upload-pack",url:a,body:m});return Uh(g.body)}catch(p){throw p.caller="git.listServerRefs",p}}async function zh({fs:t,dir:e,gitdir:r=F(e,".git")}){try{return v("fs",t),v("gitdir",r),D.listTags({fs:new M(t),gitdir:r})}catch(n){throw n.caller="git.listTags",n}}async function ks({fs:t,cache:e,gitdir:r,oid:n}){const{type:i,object:a}=await rt({fs:t,cache:e,gitdir:r,oid:n});if(i==="tag")return n=_t.from(a).parse().object,ks({fs:t,cache:e,gitdir:r,oid:n});if(i!=="commit")throw new yt(n,i,"commit");return{commit:et.from(a),oid:n}}async function bi({fs:t,cache:e,gitdir:r,oid:n}){const{commit:i,oid:a}=await ks({fs:t,cache:e,gitdir:r,oid:n});return{oid:a,commit:i.parse(),payload:i.withoutSignature()}}function Mh(t,e){return t.committer.timestamp-e.committer.timestamp}const jh="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function Ja({fs:t,cache:e,gitdir:r,oid:n,fileId:i}){if(i===jh)return;const a=n;let o;const s=await Ye({fs:t,cache:e,gitdir:r,oid:n}),h=s.tree;return i===s.oid?o=s.path:(o=await Ss({fs:t,cache:e,gitdir:r,tree:h,fileId:i,oid:a}),Array.isArray(o)&&(o.length===0?o=void 0:o.length===1&&(o=o[0]))),o}async function Ss({fs:t,cache:e,gitdir:r,tree:n,fileId:i,oid:a,filepaths:o=[],parentPath:s=""}){const h=n.entries().map(function(l){let f;return l.oid===i?(f=F(s,l.path),o.push(f)):l.type==="tree"&&(f=rt({fs:t,cache:e,gitdir:r,oid:l.oid}).then(function({object:d}){return Ss({fs:t,cache:e,gitdir:r,tree:vt.from(d),fileId:i,oid:a,filepaths:o,parentPath:F(s,l.path)})})),f});return await Promise.all(h),o}async function Lh({fs:t,cache:e,gitdir:r,filepath:n,ref:i,depth:a,since:o,force:s,follow:h}){const l=typeof o>"u"?void 0:Math.floor(o.valueOf()/1e3),f=[],d=await xr.read({fs:t,gitdir:r}),p=await D.resolve({fs:t,gitdir:r,ref:i}),m=[await bi({fs:t,cache:e,gitdir:r,oid:p})];let g,b,E;function x($){E&&n&&f.push($)}for(;m.length>0;){const $=m.pop();if(l!==void 0&&$.commit.committer.timestamp<=l)break;if(n){let A;try{A=await Hr({fs:t,cache:e,gitdir:r,oid:$.commit.tree,filepath:n}),b&&g!==A&&f.push(b),g=A,b=$,E=!0}catch(B){if(B instanceof V){let S=h&&g;if(S&&(S=await Ja({fs:t,cache:e,gitdir:r,oid:$.commit.tree,fileId:g}),S))if(Array.isArray(S)){if(b){const U=await Ja({fs:t,cache:e,gitdir:r,oid:b.commit.tree,fileId:g});if(Array.isArray(U))if(S=S.filter(O=>U.indexOf(O)===-1),S.length===1)S=S[0],n=S,b&&f.push(b);else{S=!1,b&&f.push(b);break}}}else n=S,b&&f.push(b);if(!S){if(E&&g&&(f.push(b),!s))break;if(!s&&!h)throw B}b=$,E=!1}else throw B}}else f.push($);if(a!==void 0&&f.length===a){x($);break}if(!d.has($.oid))for(const A of $.commit.parent){const B=await bi({fs:t,cache:e,gitdir:r,oid:A});m.map(S=>S.oid).includes(B.oid)||m.push(B)}m.length===0&&x($),m.sort((A,B)=>Mh(A.commit,B.commit))}return f}async function Hh({fs:t,dir:e,gitdir:r=F(e,".git"),filepath:n,ref:i="HEAD",depth:a,since:o,force:s,follow:h,cache:l={}}){try{return v("fs",t),v("gitdir",r),v("ref",i),await Lh({fs:new M(t),cache:l,gitdir:r,filepath:n,ref:i,depth:a,since:o,force:s,follow:h})}catch(f){throw f.caller="git.log",f}}async function Zh({fs:t,onSign:e,dir:r,gitdir:n=F(r,".git"),ours:i,theirs:a,fastForward:o=!0,fastForwardOnly:s=!1,dryRun:h=!1,noUpdateBranch:l=!1,abortOnConflict:f=!0,message:d,author:p,committer:m,signingKey:g,cache:b={},mergeDriver:E}){try{v("fs",t),g&&v("onSign",e);const x=new M(t),$=await Oe({fs:x,gitdir:n,author:p});if(!$&&(!s||!o))throw new gt("author");const A=await Zr({fs:x,gitdir:n,author:$,committer:m});if(!A&&(!s||!o))throw new gt("committer");return await gs({fs:x,cache:b,dir:r,gitdir:n,ours:i,theirs:a,fastForward:o,fastForwardOnly:s,dryRun:h,noUpdateBranch:l,abortOnConflict:f,message:d,author:$,committer:A,signingKey:g,onSign:e,mergeDriver:E})}catch(x){throw x.caller="git.merge",x}}const Gh={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function Bs({fs:t,cache:e,dir:r,gitdir:n=F(r,".git"),oids:i}){const a=new ao,o=[];function s(f,d){const p=Buffer.from(f,d);o.push(p),a.update(p)}async function h({stype:f,object:d}){const p=Gh[f];let m=d.length,g=m>15?128:0;const b=m&15;m=m>>>4;let E=(g|p|b).toString(16);for(s(E,"hex");g;)g=m>127?128:0,E=g|m&127,s(yi(2,E),"hex"),m=m>>>7;s(Buffer.from(await cs(d)))}s("PACK"),s("00000002","hex"),s(yi(8,i.length),"hex");for(const f of i){const{type:d,object:p}=await rt({fs:t,cache:e,gitdir:n,oid:f});await h({write:s,object:p,stype:d})}const l=a.digest();return o.push(l),o}async function Wh({fs:t,cache:e,gitdir:r,oids:n,write:i}){const a=await Bs({fs:t,cache:e,gitdir:r,oids:n}),o=Buffer.from(await mn(a)),h=`pack-${o.slice(-20).toString("hex")}.pack`;return i?(await t.write(F(r,`objects/pack/${h}`),o),{filename:h}):{filename:h,packfile:new Uint8Array(o)}}async function qh({fs:t,dir:e,gitdir:r=F(e,".git"),oids:n,write:i=!1,cache:a={}}){try{return v("fs",t),v("gitdir",r),v("oids",n),await Wh({fs:new M(t),cache:a,gitdir:r,oids:n,write:i})}catch(o){throw o.caller="git.packObjects",o}}async function Xh({fs:t,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h=F(s,".git"),ref:l,url:f,remote:d,remoteRef:p,prune:m=!1,pruneTags:g=!1,fastForward:b=!0,fastForwardOnly:E=!1,corsProxy:x,singleBranch:$,headers:A={},author:B,committer:S,signingKey:U,cache:O={}}){try{v("fs",t),v("gitdir",h);const k=new M(t),N=await Oe({fs:k,gitdir:h,author:B});if(!N)throw new gt("author");const T=await Zr({fs:k,gitdir:h,author:N,committer:S});if(!T)throw new gt("committer");return await ys({fs:k,cache:O,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h,ref:l,url:f,remote:d,remoteRef:p,fastForward:b,fastForwardOnly:E,corsProxy:x,singleBranch:$,headers:A,author:N,committer:T,signingKey:U,prune:m,pruneTags:g})}catch(k){throw k.caller="git.pull",k}}async function Yh({fs:t,cache:e,dir:r,gitdir:n=F(r,".git"),start:i,finish:a}){const o=await xr.read({fs:t,gitdir:n}),s=new Set,h=new Set;for(const d of i)s.add(await D.resolve({fs:t,gitdir:n,ref:d}));for(const d of a)try{const p=await D.resolve({fs:t,gitdir:n,ref:d});h.add(p)}catch{}const l=new Set;async function f(d){l.add(d);const{type:p,object:m}=await rt({fs:t,cache:e,gitdir:n,oid:d});if(p==="tag"){const b=_t.from(m).headers().object;return f(b)}if(p!=="commit")throw new yt(d,p,"commit");if(!o.has(d)){const b=et.from(m).headers().parent;for(d of b)!h.has(d)&&!l.has(d)&&await f(d)}}for(const d of s)await f(d);return l}async function ri({fs:t,cache:e,dir:r,gitdir:n=F(r,".git"),oids:i}){const a=new Set;async function o(s){if(a.has(s))return;a.add(s);const{type:h,object:l}=await rt({fs:t,cache:e,gitdir:n,oid:s});if(h==="tag"){const d=_t.from(l).headers().object;await o(d)}else if(h==="commit"){const d=et.from(l).headers().tree;await o(d)}else if(h==="tree"){const f=vt.from(l);for(const d of f)d.type==="blob"&&a.add(d.oid),d.type==="tree"&&await o(d.oid)}}for(const s of i)await o(s);return a}async function Kh(t){const e={};let r="";const n=ot.streamReader(t);let i=await n();for(;i!==!0;)i!==null&&(r+=i.toString("utf8")+`
`),i=await n();const a=r.toString("utf8").split(`
`);if(i=a.shift(),!i.startsWith("unpack "))throw new Re('unpack ok" or "unpack [error message]',i);e.ok=i==="unpack ok",e.ok||(e.error=i.slice(7)),e.refs={};for(const o of a){if(o.trim()==="")continue;const s=o.slice(0,2),h=o.slice(3);let l=h.indexOf(" ");l===-1&&(l=h.length);const f=h.slice(0,l),d=h.slice(l+1);e.refs[f]={ok:s==="ok",error:d}}return e}async function Vh({capabilities:t=[],triplets:e=[]}){const r=[];let n=`\0 ${t.join(" ")}`;for(const i of e)r.push(ot.encode(`${i.oldoid} ${i.oid} ${i.fullRef}${n}
`)),n="";return r.push(ot.flush()),r}async function Qh({fs:t,cache:e,http:r,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:o,onAuthFailure:s,gitdir:h,ref:l,remoteRef:f,remote:d,url:p,force:m=!1,delete:g=!1,corsProxy:b,headers:E={}}){const x=l||await Ce({fs:t,gitdir:h});if(typeof x>"u")throw new kt("ref");const $=await pt.get({fs:t,gitdir:h});d=d||await $.get(`branch.${x}.pushRemote`)||await $.get("remote.pushDefault")||await $.get(`branch.${x}.remote`)||"origin";const A=p||await $.get(`remote.${d}.pushurl`)||await $.get(`remote.${d}.url`);if(typeof A>"u")throw new kt("remote OR url");const B=f||await $.get(`branch.${x}.merge`);if(typeof A>"u")throw new kt("remoteRef");b===void 0&&(b=await $.get("http.corsProxy"));const S=await D.expand({fs:t,gitdir:h,ref:x}),U=g?"0000000000000000000000000000000000000000":await D.resolve({fs:t,gitdir:h,ref:S}),O=An.getRemoteHelperFor({url:A}),k=await O.discover({http:r,onAuth:a,onAuthSuccess:o,onAuthFailure:s,corsProxy:b,service:"git-receive-pack",url:A,headers:E,protocolVersion:1}),N=k.auth;let T;if(!B)T=S;else try{T=await D.expandAgainstMap({ref:B,map:k.refs})}catch(L){if(L instanceof V)T=B.startsWith("refs/")?B:`refs/heads/${B}`;else throw L}const C=k.refs.get(T)||"0000000000000000000000000000000000000000",P=!k.capabilities.has("no-thin");let z=new Set;if(!g){const L=[...k.refs.values()];let Y=new Set;if(C!=="0000000000000000000000000000000000000000"){const ct=await Di({fs:t,cache:e,gitdir:h,oids:[U,C]});for(const re of ct)L.push(re);P&&(Y=await ri({fs:t,cache:e,gitdir:h,oids:ct}))}if(!L.includes(U)){const ct=await Yh({fs:t,cache:e,gitdir:h,start:[U],finish:L});z=await ri({fs:t,cache:e,gitdir:h,oids:ct})}if(P){try{const ct=await D.resolve({fs:t,gitdir:h,ref:`refs/remotes/${d}/HEAD`,depth:2}),{oid:re}=await D.resolveAgainstMap({ref:ct.replace(`refs/remotes/${d}/`,""),fullref:ct,map:k.refs}),Fe=[re];for(const ne of await ri({fs:t,cache:e,gitdir:h,oids:Fe}))Y.add(ne)}catch{}for(const ct of Y)z.delete(ct)}if(U===C&&(m=!0),!m){if(S.startsWith("refs/tags")&&C!=="0000000000000000000000000000000000000000")throw new Xe("tag-exists");if(U!=="0000000000000000000000000000000000000000"&&C!=="0000000000000000000000000000000000000000"&&!await xs({fs:t,cache:e,gitdir:h,oid:U,ancestor:C,depth:-1}))throw new Xe("not-fast-forward")}}const G=ws([...k.capabilities],["report-status","side-band-64k",`agent=${Tn.agent}`]),ut=await Vh({capabilities:G,triplets:[{oldoid:C,oid:U,fullRef:T}]}),Ut=g?[]:await Bs({fs:t,cache:e,gitdir:h,oids:[...z]}),wt=await O.connect({http:r,onProgress:n,corsProxy:b,service:"git-receive-pack",url:A,auth:N,headers:E,body:[...ut,...Ut]}),{packfile:Ot,progress:ar}=await ms.demux(wt.body);if(i){const L=ps(ar);Gr(L,async Y=>{await i(Y)})}const Bt=await Kh(Ot);if(wt.headers&&(Bt.headers=wt.headers),d&&Bt.ok&&Bt.refs[T].ok){const L=`refs/remotes/${d}/${T.replace("refs/heads","")}`;g?await D.deleteRef({fs:t,gitdir:h,ref:L}):await D.writeRef({fs:t,gitdir:h,ref:L,value:U})}if(Bt.ok&&Object.values(Bt.refs).every(L=>L.ok))return Bt;{const L=Object.entries(Bt.refs).filter(([Y,ct])=>!ct.ok).map(([Y,ct])=>`
  - ${Y}: ${ct.error}`).join("");throw new Nr(L,Bt)}}async function Jh({fs:t,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,dir:s,gitdir:h=F(s,".git"),ref:l,remoteRef:f,remote:d="origin",url:p,force:m=!1,delete:g=!1,corsProxy:b,headers:E={},cache:x={}}){try{return v("fs",t),v("http",e),v("gitdir",h),await Qh({fs:new M(t),cache:x,http:e,onProgress:r,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:o,gitdir:h,ref:l,remoteRef:f,remote:d,url:p,force:m,delete:g,corsProxy:b,headers:E})}catch($){throw $.caller="git.push",$}}async function $s({fs:t,cache:e,gitdir:r,oid:n}){const{type:i,object:a}=await rt({fs:t,cache:e,gitdir:r,oid:n});if(i==="tag")return n=_t.from(a).parse().object,$s({fs:t,cache:e,gitdir:r,oid:n});if(i!=="blob")throw new yt(n,i,"blob");return{oid:n,blob:new Uint8Array(a)}}async function Is({fs:t,cache:e,gitdir:r,oid:n,filepath:i=void 0}){return i!==void 0&&(n=await Hr({fs:t,cache:e,gitdir:r,oid:n,filepath:i})),await $s({fs:t,cache:e,gitdir:r,oid:n})}async function td({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,filepath:i,cache:a={}}){try{return v("fs",t),v("gitdir",r),v("oid",n),await Is({fs:new M(t),cache:a,gitdir:r,oid:n,filepath:i})}catch(o){throw o.caller="git.readBlob",o}}async function ed({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,cache:i={}}){try{return v("fs",t),v("gitdir",r),v("oid",n),await bi({fs:new M(t),cache:i,gitdir:r,oid:n})}catch(a){throw a.caller="git.readCommit",a}}async function rd({fs:t,cache:e,gitdir:r,ref:n="refs/notes/commits",oid:i}){const a=await D.resolve({gitdir:r,fs:t,ref:n}),{blob:o}=await Is({fs:t,cache:e,gitdir:r,oid:a,filepath:i});return o}async function nd({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n="refs/notes/commits",oid:i,cache:a={}}){try{return v("fs",t),v("gitdir",r),v("ref",n),v("oid",i),await rd({fs:new M(t),cache:a,gitdir:r,ref:n,oid:i})}catch(o){throw o.caller="git.readNote",o}}async function id({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,format:i="parsed",filepath:a=void 0,encoding:o=void 0,cache:s={}}){try{v("fs",t),v("gitdir",r),v("oid",n);const h=new M(t);a!==void 0&&(n=await Hr({fs:h,cache:s,gitdir:r,oid:n,filepath:a}));const f=await rt({fs:h,cache:s,gitdir:r,oid:n,format:i==="parsed"?"content":i});if(f.oid=n,i==="parsed")switch(f.format="parsed",f.type){case"commit":f.object=et.from(f.object).parse();break;case"tree":f.object=vt.from(f.object).entries();break;case"blob":o?f.object=f.object.toString(o):(f.object=new Uint8Array(f.object),f.format="content");break;case"tag":f.object=_t.from(f.object).parse();break;default:throw new yt(f.oid,f.type,"blob|commit|tag|tree")}else(f.format==="deflated"||f.format==="wrapped")&&(f.type=f.format);return f}catch(h){throw h.caller="git.readObject",h}}async function ad({fs:t,cache:e,gitdir:r,oid:n}){const{type:i,object:a}=await rt({fs:t,cache:e,gitdir:r,oid:n,format:"content"});if(i!=="tag")throw new yt(n,i,"tag");const o=_t.from(a);return{oid:n,tag:o.parse(),payload:o.payload()}}async function od({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,cache:i={}}){try{return v("fs",t),v("gitdir",r),v("oid",n),await ad({fs:new M(t),cache:i,gitdir:r,oid:n})}catch(a){throw a.caller="git.readTag",a}}async function sd({fs:t,dir:e,gitdir:r=F(e,".git"),oid:n,filepath:i=void 0,cache:a={}}){try{return v("fs",t),v("gitdir",r),v("oid",n),await ir({fs:new M(t),cache:a,gitdir:r,oid:n,filepath:i})}catch(o){throw o.caller="git.readTree",o}}async function cd({fs:t,dir:e,gitdir:r=F(e,".git"),filepath:n,cache:i={}}){try{v("fs",t),v("gitdir",r),v("filepath",n),await dt.acquire({fs:new M(t),gitdir:r,cache:i},async function(a){a.delete({filepath:n})})}catch(a){throw a.caller="git.remove",a}}async function fd({fs:t,cache:e,onSign:r,gitdir:n,ref:i="refs/notes/commits",oid:a,author:o,committer:s,signingKey:h}){let l;try{l=await D.resolve({gitdir:n,fs:t,ref:i})}catch(g){if(!(g instanceof V))throw g}let d=(await ir({fs:t,gitdir:n,oid:l||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;d=d.filter(g=>g.path!==a);const p=await Fi({fs:t,gitdir:n,tree:d});return await In({fs:t,cache:e,onSign:r,gitdir:n,ref:i,tree:p,parent:l&&[l],message:`Note removed by 'isomorphic-git removeNote'
`,author:o,committer:s,signingKey:h})}async function ld({fs:t,onSign:e,dir:r,gitdir:n=F(r,".git"),ref:i="refs/notes/commits",oid:a,author:o,committer:s,signingKey:h,cache:l={}}){try{v("fs",t),v("gitdir",n),v("oid",a);const f=new M(t),d=await Oe({fs:f,gitdir:n,author:o});if(!d)throw new gt("author");const p=await Zr({fs:f,gitdir:n,author:d,committer:s});if(!p)throw new gt("committer");return await fd({fs:f,cache:l,onSign:e,gitdir:n,ref:i,oid:a,author:d,committer:p,signingKey:h})}catch(f){throw f.caller="git.removeNote",f}}async function ud({fs:t,gitdir:e,oldref:r,ref:n,checkout:i=!1}){if(n!==Wt.clean(n))throw new te(n,Wt.clean(n));if(r!==Wt.clean(r))throw new te(r,Wt.clean(r));const a=`refs/heads/${r}`,o=`refs/heads/${n}`;if(await D.exists({fs:t,gitdir:e,ref:o}))throw new Nt("branch",n,!1);const h=await D.resolve({fs:t,gitdir:e,ref:a,depth:1});await D.writeRef({fs:t,gitdir:e,ref:o,value:h}),await D.deleteRef({fs:t,gitdir:e,ref:a});const f=await Ce({fs:t,gitdir:e,fullname:!0})===a;(i||f)&&await D.writeSymbolicRef({fs:t,gitdir:e,ref:"HEAD",value:o})}async function hd({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n,oldref:i,checkout:a=!1}){try{return v("fs",t),v("gitdir",r),v("ref",n),v("oldref",i),await ud({fs:new M(t),gitdir:r,ref:n,oldref:i,checkout:a})}catch(o){throw o.caller="git.renameBranch",o}}async function As({gitdir:t,type:e,object:r}){return Jt(er.wrap({type:e,object:r}))}async function dd({fs:t,dir:e,gitdir:r=F(e,".git"),filepath:n,ref:i,cache:a={}}){try{v("fs",t),v("gitdir",r),v("filepath",n);const o=new M(t);let s,h;try{s=await D.resolve({fs:o,gitdir:r,ref:i||"HEAD"})}catch(d){if(i)throw d}if(s)try{s=await Hr({fs:o,cache:a,gitdir:r,oid:s,filepath:n})}catch{s=null}let l={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const f=e&&await o.read(F(e,n));f&&(h=await As({gitdir:r,type:"blob",object:f}),s===h&&(l=await o.lstat(F(e,n)))),await dt.acquire({fs:o,gitdir:r,cache:a},async function(d){d.delete({filepath:n}),s&&d.insert({filepath:n,stats:l,oid:s})})}catch(o){throw o.caller="git.reset",o}}async function wd({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n,depth:i}){try{return v("fs",t),v("gitdir",r),v("ref",n),await D.resolve({fs:new M(t),gitdir:r,ref:n,depth:i})}catch(a){throw a.caller="git.resolveRef",a}}async function pd({fs:t,dir:e,gitdir:r=F(e,".git"),path:n,value:i,append:a=!1}){try{v("fs",t),v("gitdir",r),v("path",n);const o=new M(t),s=await pt.get({fs:o,gitdir:r});a?await s.append(n,i):await s.set(n,i),await pt.save({fs:o,gitdir:r,config:s})}catch(o){throw o.caller="git.setConfig",o}}async function md({fs:t,dir:e,gitdir:r=F(e,".git"),filepath:n,cache:i={}}){try{v("fs",t),v("gitdir",r),v("filepath",n);const a=new M(t);if(await $n.isIgnored({fs:a,gitdir:r,dir:e,filepath:n}))return"ignored";const s=await _d({fs:a,cache:i,gitdir:r}),h=await Ts({fs:a,cache:i,gitdir:r,tree:s,path:n}),l=await dt.acquire({fs:a,gitdir:r,cache:i},async function(b){for(const E of b)if(E.path===n)return E;return null}),f=await a.lstat(F(e,n)),d=h!==null,p=l!==null,m=f!==null,g=async()=>{if(p&&!ln(l,f))return l.oid;{const b=await a.read(F(e,n)),E=await As({gitdir:r,type:"blob",object:b});return p&&l.oid===E&&f.size!==-1&&dt.acquire({fs:a,gitdir:r,cache:i},async function(x){x.insert({filepath:n,stats:f,oid:E})}),E}};if(!d&&!m&&!p)return"absent";if(!d&&!m&&p)return"*absent";if(!d&&m&&!p)return"*added";if(!d&&m&&p)return await g()===l.oid?"added":"*added";if(d&&!m&&!p)return"deleted";if(d&&!m&&p)return h===l.oid,"*deleted";if(d&&m&&!p)return await g()===h?"*undeleted":"*undeletemodified";if(d&&m&&p){const b=await g();return b===h?b===l.oid?"unmodified":"*unmodified":b===l.oid?"modified":"*modified"}}catch(a){throw a.caller="git.status",a}}async function Ts({fs:t,cache:e,gitdir:r,tree:n,path:i}){typeof i=="string"&&(i=i.split("/"));const a=i.shift();for(const o of n)if(o.path===a){if(i.length===0)return o.oid;const{type:s,object:h}=await rt({fs:t,cache:e,gitdir:r,oid:o.oid});if(s==="tree"){const l=vt.from(h);return Ts({fs:t,cache:e,gitdir:r,tree:l,path:i})}if(s==="blob")throw new yt(o.oid,s,"blob",i.join("/"))}return null}async function _d({fs:t,cache:e,gitdir:r}){let n;try{n=await D.resolve({fs:t,gitdir:r,ref:"HEAD"})}catch(a){if(a instanceof V)return[]}const{tree:i}=await ir({fs:t,cache:e,gitdir:r,oid:n});return i}async function gd({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n="HEAD",filepaths:i=["."],filter:a,cache:o={},ignored:s=!1}){try{v("fs",t),v("gitdir",r),v("ref",n);const h=new M(t);return await Ke({fs:h,cache:o,dir:e,gitdir:r,trees:[we({ref:n}),Bn(),Sn()],map:async function(l,[f,d,p]){if(!f&&!p&&d&&!s&&await $n.isIgnored({fs:h,dir:e,filepath:l})||!i.some(U=>hs(l,U)))return null;if(a&&!a(l))return;const[m,g,b]=await Promise.all([f&&f.type(),d&&d.type(),p&&p.type()]),E=[m,g,b].includes("blob");if((m==="tree"||m==="special")&&!E)return;if(m==="commit")return null;if((g==="tree"||g==="special")&&!E)return;if(b==="commit")return null;if((b==="tree"||b==="special")&&!E)return;const x=m==="blob"?await f.oid():void 0,$=b==="blob"?await p.oid():void 0;let A;m!=="blob"&&g==="blob"&&b!=="blob"?A="42":g==="blob"&&(A=await d.oid());const B=[void 0,x,A,$],S=B.map(U=>B.indexOf(U));return S.shift(),[l,...S]}})}catch(h){throw h.caller="git.statusMatrix",h}}async function yd({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n,object:i,force:a=!1}){try{v("fs",t),v("gitdir",r),v("ref",n);const o=new M(t);if(n===void 0)throw new kt("ref");n=n.startsWith("refs/tags/")?n:`refs/tags/${n}`;const s=await D.resolve({fs:o,gitdir:r,ref:i||"HEAD"});if(!a&&await D.exists({fs:o,gitdir:r,ref:n}))throw new Nt("tag",n);await D.writeRef({fs:o,gitdir:r,ref:n,value:s})}catch(o){throw o.caller="git.tag",o}}async function bd({fs:t,dir:e,gitdir:r=F(e,".git"),cache:n={},filepath:i,oid:a,mode:o,add:s,remove:h,force:l}){try{v("fs",t),v("gitdir",r),v("filepath",i);const f=new M(t);if(h)return await dt.acquire({fs:f,gitdir:r,cache:n},async function(p){let m;if(!l&&(m=await f.lstat(F(e,i)),m)){if(m.isDirectory())throw new _e("directory");return}p.has({filepath:i})&&p.delete({filepath:i})});let d;if(!a){if(d=await f.lstat(F(e,i)),!d)throw new V(`file at "${i}" on disk and "remove" not set`);if(d.isDirectory())throw new _e("directory")}return await dt.acquire({fs:f,gitdir:r,cache:n},async function(p){if(!s&&!p.has({filepath:i}))throw new V(`file at "${i}" in index and "add" not set`);let m={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:o,uid:0,gid:0,size:0};if(!a){m=d;const g=m.isSymbolicLink()?await f.readlink(F(e,i)):await f.read(F(e,i));a=await St({fs:f,gitdir:r,type:"blob",format:"content",object:g})}return p.insert({filepath:i,oid:a,stats:m}),a})}catch(f){throw f.caller="git.updateIndex",f}}function vd(){try{return Tn.version}catch(t){throw t.caller="git.version",t}}async function xd({fs:t,dir:e,gitdir:r=F(e,".git"),trees:n,map:i,reduce:a,iterate:o,cache:s={}}){try{return v("fs",t),v("gitdir",r),v("trees",n),await Ke({fs:new M(t),cache:s,dir:e,gitdir:r,trees:n,map:i,reduce:a,iterate:o})}catch(h){throw h.caller="git.walk",h}}async function Ed({fs:t,dir:e,gitdir:r=F(e,".git"),blob:n}){try{return v("fs",t),v("gitdir",r),v("blob",n),await St({fs:new M(t),gitdir:r,type:"blob",object:n,format:"content"})}catch(i){throw i.caller="git.writeBlob",i}}async function kd({fs:t,gitdir:e,commit:r}){const n=et.from(r).toObject();return await St({fs:t,gitdir:e,type:"commit",object:n,format:"content"})}async function Sd({fs:t,dir:e,gitdir:r=F(e,".git"),commit:n}){try{return v("fs",t),v("gitdir",r),v("commit",n),await kd({fs:new M(t),gitdir:r,commit:n})}catch(i){throw i.caller="git.writeCommit",i}}async function Bd({fs:t,dir:e,gitdir:r=F(e,".git"),type:n,object:i,format:a="parsed",oid:o,encoding:s=void 0}){try{const h=new M(t);if(a==="parsed"){switch(n){case"commit":i=et.from(i).toObject();break;case"tree":i=vt.from(i).toObject();break;case"blob":i=Buffer.from(i,s);break;case"tag":i=_t.from(i).toObject();break;default:throw new yt(o||"",n,"blob|commit|tag|tree")}a="content"}return o=await St({fs:h,gitdir:r,type:n,object:i,oid:o,format:a}),o}catch(h){throw h.caller="git.writeObject",h}}async function $d({fs:t,dir:e,gitdir:r=F(e,".git"),ref:n,value:i,force:a=!1,symbolic:o=!1}){try{v("fs",t),v("gitdir",r),v("ref",n),v("value",i);const s=new M(t);if(n!==Wt.clean(n))throw new te(n,Wt.clean(n));if(!a&&await D.exists({fs:s,gitdir:r,ref:n}))throw new Nt("ref",n);o?await D.writeSymbolicRef({fs:s,gitdir:r,ref:n,value:i}):(i=await D.resolve({fs:s,gitdir:r,ref:i}),await D.writeRef({fs:s,gitdir:r,ref:n,value:i}))}catch(s){throw s.caller="git.writeRef",s}}async function Id({fs:t,gitdir:e,tag:r}){const n=_t.from(r).toObject();return await St({fs:t,gitdir:e,type:"tag",object:n,format:"content"})}async function Ad({fs:t,dir:e,gitdir:r=F(e,".git"),tag:n}){try{return v("fs",t),v("gitdir",r),v("tag",n),await Id({fs:new M(t),gitdir:r,tag:n})}catch(i){throw i.caller="git.writeTag",i}}async function Td({fs:t,dir:e,gitdir:r=F(e,".git"),tree:n}){try{return v("fs",t),v("gitdir",r),v("tree",n),await Fi({fs:new M(t),gitdir:r,tree:n})}catch(i){throw i.caller="git.writeTree",i}}var Dd={Errors:lu,STAGE:Sn,TREE:we,WORKDIR:Bn,add:Au,abortMerge:ku,addNote:Ru,addRemote:Ou,annotatedTag:Fu,branch:Uu,checkout:Pu,clone:Yu,commit:Ku,getConfig:_h,getConfigAll:yh,setConfig:pd,currentBranch:Vu,deleteBranch:Ju,deleteRef:th,deleteRemote:rh,deleteTag:ih,expandOid:ch,expandRef:fh,fastForward:dh,fetch:wh,findMergeBase:ph,findRoot:mh,getRemoteInfo:bh,getRemoteInfo2:vh,hashBlob:Eh,indexPack:Sh,init:Bh,isDescendent:$h,isIgnored:Ih,listBranches:Ah,listFiles:Rh,listNotes:Ch,listRemotes:Nh,listServerRefs:Ph,listTags:zh,log:Hh,merge:Zh,packObjects:qh,pull:Xh,push:Jh,readBlob:td,readCommit:ed,readNote:nd,readObject:id,readTag:od,readTree:sd,remove:cd,removeNote:ld,renameBranch:hd,resetIndex:dd,updateIndex:bd,resolveRef:wd,status:md,statusMatrix:gd,tag:yd,version:vd,walk:xd,writeBlob:Ed,writeCommit:Sd,writeObject:Bd,writeRef:$d,writeTag:Ad,writeTree:Td};export{lu as Errors,Sn as STAGE,we as TREE,Bn as WORKDIR,ku as abortMerge,Au as add,Ru as addNote,Ou as addRemote,Fu as annotatedTag,Uu as branch,Pu as checkout,Yu as clone,Ku as commit,Vu as currentBranch,Dd as default,Ju as deleteBranch,th as deleteRef,rh as deleteRemote,ih as deleteTag,ch as expandOid,fh as expandRef,dh as fastForward,wh as fetch,ph as findMergeBase,mh as findRoot,_h as getConfig,yh as getConfigAll,bh as getRemoteInfo,vh as getRemoteInfo2,Eh as hashBlob,Sh as indexPack,Bh as init,$h as isDescendent,Ih as isIgnored,Ah as listBranches,Rh as listFiles,Ch as listNotes,Nh as listRemotes,Ph as listServerRefs,zh as listTags,Hh as log,Zh as merge,qh as packObjects,Xh as pull,Jh as push,td as readBlob,ed as readCommit,nd as readNote,id as readObject,od as readTag,sd as readTree,cd as remove,ld as removeNote,hd as renameBranch,dd as resetIndex,wd as resolveRef,pd as setConfig,md as status,gd as statusMatrix,yd as tag,bd as updateIndex,vd as version,xd as walk,Ed as writeBlob,Sd as writeCommit,Bd as writeObject,$d as writeRef,Ad as writeTag,Td as writeTree};
